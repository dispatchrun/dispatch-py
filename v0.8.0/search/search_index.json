{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Python SDK","text":"<p>This is the API reference for the Python SDK of Dispatch.</p> <ul> <li>Tutorials and guides: docs.dispatch.run.</li> <li>Source: dispatchrun/dispatch-py.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> dispatch<ul> <li> any</li> <li> asyncio<ul> <li> fastapi</li> </ul> </li> <li> config</li> <li> coroutine</li> <li> error</li> <li> experimental<ul> <li> durable<ul> <li> function</li> <li> registry</li> </ul> </li> <li> lambda_handler</li> </ul> </li> <li> fastapi</li> <li> flask</li> <li> function</li> <li> http</li> <li> id</li> <li> integrations<ul> <li> http</li> <li> httpx</li> <li> openai</li> <li> requests</li> <li> slack</li> </ul> </li> <li> proto</li> <li> scheduler</li> <li> signature<ul> <li> digest</li> <li> key</li> <li> request</li> </ul> </li> <li> status</li> <li> test</li> </ul> </li> </ul>"},{"location":"reference/dispatch/","title":"Index","text":""},{"location":"reference/dispatch/#dispatch","title":"dispatch","text":"<p>The Dispatch SDK for Python.</p>"},{"location":"reference/dispatch/#dispatch.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/#dispatch.Client","title":"Client","text":"<pre><code>Client(\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/#dispatch.Client.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; List[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/#dispatch.Registry","title":"Registry","text":"<pre><code>Registry(\n    name: str,\n    client: Optional[Client] = None,\n    endpoint: Optional[str] = None,\n)\n</code></pre> <p>Registry of functions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A unique name for the registry.</p> required <code>endpoint</code> <code>Optional[str]</code> <p>URL of the endpoint that the function is accessible from.</p> <code>None</code> <code>client</code> <code>Optional[Client]</code> <p>Client instance to use for dispatching calls to registered functions. Defaults to creating a new client instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/#dispatch.Registry.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the registry, removing it and all its functions from the dispatch application.</p>"},{"location":"reference/dispatch/#dispatch.Registry.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/#dispatch.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/#dispatch.Registry.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/#dispatch.Reset","title":"Reset","text":"<pre><code>Reset(\n    func: Union[\n        AsyncFunction[P, T], BlockingFunction[P, T]\n    ],\n    *args: args,\n    **kwargs: kwargs\n)\n</code></pre> <p>             Bases: <code>TailCall</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/#dispatch.Call","title":"Call  <code>dataclass</code>","text":"<pre><code>Call(\n    function: str,\n    input: Optional[Any] = None,\n    endpoint: Optional[str] = None,\n    correlation_id: Optional[int] = None,\n)\n</code></pre> <p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/#dispatch.Error","title":"Error  <code>dataclass</code>","text":"<pre><code>Error(\n    status: Status,\n    type: str,\n    message: str,\n    value: Optional[Exception] = None,\n    traceback: Optional[bytes] = None,\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str</code> <p>arbitrary string, used for humans.</p> required <code>message</code> <code>str</code> <p>arbitrary message.</p> required <code>value</code> <code>Optional[Exception]</code> <p>arbitrary exception from which the error is derived. Optional.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/#dispatch.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Optional[Status] = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/#dispatch.Error.to_exception","title":"to_exception","text":"<pre><code>to_exception() -&gt; Exception\n</code></pre> <p>Returns an equivalent exception.</p>"},{"location":"reference/dispatch/#dispatch.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/#dispatch.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/#dispatch.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/#dispatch.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(\n    value: Any, status: Optional[Status] = None\n) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/#dispatch.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/#dispatch.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(\n    tail_call: Call, status: Status = Status.OK\n) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/#dispatch.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: Optional[CallResult] = None,\n    tail_call: Optional[Call] = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/#dispatch.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(\n    coroutine_state: Any = None,\n    calls: Optional[List[Call]] = None,\n    min_results: int = 1,\n    max_results: int = 10,\n    max_wait_seconds: Optional[int] = None,\n) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/#dispatch.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/#dispatch.all","title":"all","text":"<pre><code>all(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until all coroutines return or any coroutine raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/#dispatch.call","title":"call","text":"<pre><code>call(call: Call) -&gt; Any\n</code></pre> <p>Make an asynchronous function call and return its result. If the function call fails with an error, the error is raised.</p>"},{"location":"reference/dispatch/#dispatch.gather","title":"gather","text":"<pre><code>gather(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Alias for all.</p>"},{"location":"reference/dispatch/#dispatch.race","title":"race","text":"<pre><code>race(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/#dispatch.run","title":"run","text":"<pre><code>run(\n    coro: Coroutine[Any, Any, T],\n    addr: Optional[str] = None,\n) -&gt; T\n</code></pre> <p>Run the default dispatch server. The default server uses a function registry where functions tagged by the <code>@dispatch.function</code> decorator are registered.</p> <p>This function is intended to be used with the <code>dispatch</code> CLI tool, which automatically configures environment variables to connect the local server to the Dispatch bridge API.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>Coroutine[Any, Any, T]</code> <p>The coroutine to run as the entrypoint, the function returns when the coroutine returns.</p> required <code>addr</code> <code>Optional[str]</code> <p>The address to bind the server to. If not provided, the server will bind to the address specified by the <code>DISPATCH_ENDPOINT_ADDR</code> environment variable. If the environment variable is not set, the server will bind to <code>localhost:8000</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The value returned by the coroutine.</p>"},{"location":"reference/dispatch/any/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> any","text":""},{"location":"reference/dispatch/any/#dispatch.any","title":"any","text":""},{"location":"reference/dispatch/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/dispatch/config/#dispatch.config","title":"config","text":""},{"location":"reference/dispatch/coroutine/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine","title":"coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.AnyException","title":"AnyException","text":"<pre><code>AnyException(exceptions: List[Exception])\n</code></pre> <p>             Bases: <code>RuntimeError</code></p> <p>Error indicating that all coroutines passed to any() failed with an exception.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.call","title":"call","text":"<pre><code>call(call: Call) -&gt; Any\n</code></pre> <p>Make an asynchronous function call and return its result. If the function call fails with an error, the error is raised.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.gather","title":"gather","text":"<pre><code>gather(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Alias for all.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.all","title":"all","text":"<pre><code>all(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until all coroutines return or any coroutine raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.any","title":"any","text":"<pre><code>any(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or all coroutines raises an error. If all coroutines fail with uncaught exceptions, the exception(s) will be re-raised here.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.race","title":"race","text":"<pre><code>race(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/error/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> error","text":""},{"location":"reference/dispatch/error/#dispatch.error","title":"error","text":""},{"location":"reference/dispatch/error/#dispatch.error.DispatchError","title":"DispatchError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Dispatch exceptions.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TimeoutError","title":"TimeoutError","text":"<p>             Bases: <code>DispatchError</code>, <code>TimeoutError</code></p> <p>Operation timed out.</p>"},{"location":"reference/dispatch/error/#dispatch.error.ThrottleError","title":"ThrottleError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Operation was throttled.</p>"},{"location":"reference/dispatch/error/#dispatch.error.InvalidArgumentError","title":"InvalidArgumentError","text":"<p>             Bases: <code>DispatchError</code>, <code>ValueError</code></p> <p>Invalid argument was received.</p>"},{"location":"reference/dispatch/error/#dispatch.error.InvalidResponseError","title":"InvalidResponseError","text":"<p>             Bases: <code>DispatchError</code>, <code>ValueError</code></p> <p>Invalid response was received.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TemporaryError","title":"TemporaryError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic temporary error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.PermanentError","title":"PermanentError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic permanent error. Used in cases where a more specific error class is not available, but the operation that failed should not be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.IncompatibleStateError","title":"IncompatibleStateError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Coroutine state is incompatible with the current interpreter and application revision.</p>"},{"location":"reference/dispatch/error/#dispatch.error.DNSError","title":"DNSError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic DNS error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TCPError","title":"TCPError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic TCP error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.HTTPError","title":"HTTPError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic HTTP error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.UnauthenticatedError","title":"UnauthenticatedError","text":"<p>             Bases: <code>DispatchError</code></p> <p>The caller did not authenticate with the resource.</p>"},{"location":"reference/dispatch/error/#dispatch.error.PermissionDeniedError","title":"PermissionDeniedError","text":"<p>             Bases: <code>DispatchError</code>, <code>PermissionError</code></p> <p>The caller does not have access to the resource.</p>"},{"location":"reference/dispatch/error/#dispatch.error.NotFoundError","title":"NotFoundError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic not found error. Used in cases where a more specific error class is not available, but the operation that failed should not be attempted again.</p>"},{"location":"reference/dispatch/fastapi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fastapi","text":""},{"location":"reference/dispatch/fastapi/#dispatch.fastapi","title":"fastapi","text":"<p>Integration of Dispatch functions with FastAPI.</p> <p>Example:</p> <pre><code>import fastapi\nfrom dispatch.fastapi import Dispatch\n\napp = fastapi.FastAPI()\ndispatch = Dispatch(app)\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\ndef read_root():\n    my_function.dispatch()\n</code></pre>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.AsyncDispatch","title":"AsyncDispatch","text":"<pre><code>AsyncDispatch(\n    app: FastAPI,\n    registry: Optional[Registry] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>AsyncFunctionService</code></p> <p>A Dispatch instance, powered by FastAPI.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app to configure.</p> required <code>registry</code> <code>Optional[Registry]</code> <p>A registry of functions to expose. If omitted, the default registry is used.</p> <code>None</code> <code>verification_key</code> <code>Optional[Union[Ed25519PublicKey, str, bytes]]</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable if omitted. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format. If not set, request signature verification is disabled (a warning will be logged by the constructor).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.AsyncDispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/flask/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> flask","text":""},{"location":"reference/dispatch/flask/#dispatch.flask","title":"flask","text":"<p>Integration of Dispatch functions with Flask.</p> <p>Example:</p> <pre><code>from flask import Flask\nfrom dispatch.flask import Dispatch\n\napp = Flask(__name__)\ndispatch = Dispatch(app)\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\ndef read_root():\n    my_function.dispatch()\n</code></pre>"},{"location":"reference/dispatch/flask/#dispatch.flask.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    app: Flask,\n    registry: Optional[Registry] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>BlockingFunctionService</code></p> <p>A Dispatch instance, powered by Flask.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Flask</code> <p>The Flask app to configure.</p> required <code>registry</code> <code>Optional[Registry]</code> <p>A registry of functions to expose. If omitted, the default registry is used.</p> <code>None</code> <code>verification_key</code> <code>Optional[Union[Ed25519PublicKey, str, bytes]]</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable if omitted. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format. If not set, request signature verification is disabled (a warning will be logged by the constructor).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/flask/#dispatch.flask.Dispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/function/#dispatch.function","title":"function","text":""},{"location":"reference/dispatch/function/#dispatch.function.PrimitiveFunctionType","title":"PrimitiveFunctionType  <code>module-attribute</code>","text":"<pre><code>PrimitiveFunctionType: TypeAlias = Callable[\n    [Input], Awaitable[Output]\n]\n</code></pre> <p>A primitive function is a function that accepts a dispatch.proto.Input and unconditionally returns a dispatch.proto.Output. It must not raise exceptions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.DEFAULT_REGISTRY","title":"DEFAULT_REGISTRY  <code>module-attribute</code>","text":"<pre><code>DEFAULT_REGISTRY: Optional[Registry] = None\n</code></pre> <p>The default registry for dispatch functions, used by dispatch applications when no custom registry is provided.</p> <p>In most cases, applications do not need to create a custom registry, so this one would be used by default.</p> <p>The default registry use DISPATCH_* environment variables for configuration, or is uninitialized if they are not set.</p>"},{"location":"reference/dispatch/function/#dispatch.function.AsyncFunction","title":"AsyncFunction","text":"<pre><code>AsyncFunction(\n    registry: Registry,\n    name: str,\n    primitive_func: PrimitiveFunctionType,\n)\n</code></pre> <p>             Bases: <code>PrimitiveFunction</code>, <code>Generic[P, T]</code></p> <p>Callable wrapper around a function meant to be used throughout the Dispatch Python SDK.</p>"},{"location":"reference/dispatch/function/#dispatch.function.AsyncFunction.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args: args, **kwargs: kwargs\n) -&gt; Coroutine[Any, Any, T]\n</code></pre> <p>Call the function asynchronously (through Dispatch), and return a coroutine that can be awaited to retrieve the call result.</p>"},{"location":"reference/dispatch/function/#dispatch.function.AsyncFunction.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(*args: args, **kwargs: kwargs) -&gt; DispatchID\n</code></pre> <p>Dispatch an asynchronous call to the function without waiting for a result.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p>"},{"location":"reference/dispatch/function/#dispatch.function.AsyncFunction.build_call","title":"build_call","text":"<pre><code>build_call(*args: args, **kwargs: kwargs) -&gt; Call\n</code></pre> <p>Create a Call for this function with the provided input. Useful to generate calls when using the Client.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Client.dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.BlockingFunction","title":"BlockingFunction","text":"<pre><code>BlockingFunction(func: AsyncFunction[P, T])\n</code></pre> <p>             Bases: <code>Generic[P, T]</code></p> <p>BlockingFunction is like Function but exposes a blocking API instead of functions that use asyncio.</p> <p>Applications typically don't create instances of BlockingFunction directly, and instead use decorators from packages that provide integrations with Python frameworks.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Reset","title":"Reset","text":"<pre><code>Reset(\n    func: Union[\n        AsyncFunction[P, T], BlockingFunction[P, T]\n    ],\n    *args: args,\n    **kwargs: kwargs\n)\n</code></pre> <p>             Bases: <code>TailCall</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry","title":"Registry","text":"<pre><code>Registry(\n    name: str,\n    client: Optional[Client] = None,\n    endpoint: Optional[str] = None,\n)\n</code></pre> <p>Registry of functions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A unique name for the registry.</p> required <code>endpoint</code> <code>Optional[str]</code> <p>URL of the endpoint that the function is accessible from.</p> <code>None</code> <code>client</code> <code>Optional[Client]</code> <p>Client instance to use for dispatching calls to registered functions. Defaults to creating a new client instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the registry, removing it and all its functions from the dispatch application.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Client","title":"Client","text":"<pre><code>Client(\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Client.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; List[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch","title":"Batch","text":"<pre><code>Batch(client: Client)\n</code></pre> <p>A batch of calls to dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.add","title":"add","text":"<pre><code>add(\n    func: AsyncFunction[P, T],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; Batch\n</code></pre> <p>Add a call to the specified function to the batch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.add_call","title":"add_call","text":"<pre><code>add_call(call: Call) -&gt; Batch\n</code></pre> <p>Add a Call to the batch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Reset the batch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch() -&gt; List[DispatchID]\n</code></pre> <p>Dispatch dispatches the calls asynchronously.</p> <p>The batch is reset when the calls are dispatched successfully.</p> <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order they</p> <code>List[DispatchID]</code> <p>were added.</p>"},{"location":"reference/dispatch/function/#dispatch.function.default_registry","title":"default_registry","text":"<pre><code>default_registry() -&gt; Registry\n</code></pre> <p>Returns the default registry for dispatch functions.</p> <p>The function initializes the default registry if it has not been initialized yet, using the DISPATCH_* environment variables for configuration.</p> <p>Returns:</p> Name Type Description <code>Registry</code> <code>Registry</code> <p>The default registry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DISPATCH_API_KEY or DISPATCH_ENDPOINT_URL environment variables are missing.</p>"},{"location":"reference/dispatch/http/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> http","text":""},{"location":"reference/dispatch/http/#dispatch.http","title":"http","text":"<p>Integration of Dispatch functions with http.</p>"},{"location":"reference/dispatch/http/#dispatch.http.BaseFunctionService","title":"BaseFunctionService","text":"<pre><code>BaseFunctionService(\n    registry: Optional[Registry] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>FunctionService is an abstract class intended to be inherited by objects that integrate dispatch with other server application frameworks.</p> <p>An application encapsulates a function Registry, and implements the API common to all dispatch integrations.</p>"},{"location":"reference/dispatch/http/#dispatch.http.BaseFunctionService.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/http/#dispatch.http.BlockingFunctionService","title":"BlockingFunctionService","text":"<pre><code>BlockingFunctionService(\n    registry: Optional[Registry] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>BaseFunctionService</code></p> <p>BlockingFunctionService is a variant of FunctionService which decorates dispatch functions with a synchronous API instead of using asyncio.</p>"},{"location":"reference/dispatch/http/#dispatch.http.BlockingFunctionService.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/http/#dispatch.http.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    registry: Registry,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>Application</code></p> <p>A Dispatch instance servicing as a http server.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>Registry</code> <p>The registry of functions to be serviced.</p> required <code>verification_key</code> <code>Optional[Union[Ed25519PublicKey, str, bytes]]</code> <p>The verification key to use for requests.</p> <code>None</code>"},{"location":"reference/dispatch/id/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> id","text":""},{"location":"reference/dispatch/id/#dispatch.id","title":"id","text":""},{"location":"reference/dispatch/id/#dispatch.id.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/proto/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto","title":"proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto.TailCall","title":"TailCall","text":"<pre><code>TailCall(\n    call: Call, status: Status = Status.TEMPORARY_ERROR\n)\n</code></pre> <p>             Bases: <code>Exception</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Arguments","title":"Arguments  <code>dataclass</code>","text":"<pre><code>Arguments(args: Tuple[Any, ...], kwargs: Dict[str, Any])\n</code></pre> <p>A container for positional and keyword arguments.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(\n    value: Any, status: Optional[Status] = None\n) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(\n    tail_call: Call, status: Status = Status.OK\n) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: Optional[CallResult] = None,\n    tail_call: Optional[Call] = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(\n    coroutine_state: Any = None,\n    calls: Optional[List[Call]] = None,\n    min_results: int = 1,\n    max_results: int = 10,\n    max_wait_seconds: Optional[int] = None,\n) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Call","title":"Call  <code>dataclass</code>","text":"<pre><code>Call(\n    function: str,\n    input: Optional[Any] = None,\n    endpoint: Optional[str] = None,\n    correlation_id: Optional[int] = None,\n)\n</code></pre> <p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.CallResult","title":"CallResult  <code>dataclass</code>","text":"<pre><code>CallResult(\n    correlation_id: Optional[int] = None,\n    output: Optional[Any] = None,\n    error: Optional[Error] = None,\n    dispatch_id: DispatchID = \"\",\n)\n</code></pre> <p>Result of a Call.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error","title":"Error  <code>dataclass</code>","text":"<pre><code>Error(\n    status: Status,\n    type: str,\n    message: str,\n    value: Optional[Exception] = None,\n    traceback: Optional[bytes] = None,\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str</code> <p>arbitrary string, used for humans.</p> required <code>message</code> <code>str</code> <p>arbitrary message.</p> required <code>value</code> <code>Optional[Exception]</code> <p>arbitrary exception from which the error is derived. Optional.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Optional[Status] = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error.to_exception","title":"to_exception","text":"<pre><code>to_exception() -&gt; Exception\n</code></pre> <p>Returns an equivalent exception.</p>"},{"location":"reference/dispatch/scheduler/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> scheduler","text":""},{"location":"reference/dispatch/scheduler/#dispatch.scheduler","title":"scheduler","text":""},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CoroutineResult","title":"CoroutineResult  <code>dataclass</code>","text":"<pre><code>CoroutineResult(\n    coroutine_id: CoroutineID,\n    value: Optional[Any] = None,\n    error: Optional[Exception] = None,\n    call: Optional[Call] = None,\n    status: Status = Status.OK,\n)\n</code></pre> <p>The result from running a coroutine to completion.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CallResult","title":"CallResult  <code>dataclass</code>","text":"<pre><code>CallResult(\n    call_id: CallID,\n    value: Optional[Any] = None,\n    error: Optional[Exception] = None,\n)\n</code></pre> <p>The result of an asynchronous function call.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CallFuture","title":"CallFuture  <code>dataclass</code>","text":"<pre><code>CallFuture(\n    result: Optional[CallResult] = None,\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.call() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.AllFuture","title":"AllFuture  <code>dataclass</code>","text":"<pre><code>AllFuture(\n    order: List[CoroutineID] = list(),\n    waiting: Set[CoroutineID] = set(),\n    results: Dict[CoroutineID, CoroutineResult] = dict(),\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.all() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.AnyFuture","title":"AnyFuture  <code>dataclass</code>","text":"<pre><code>AnyFuture(\n    order: List[CoroutineID] = list(),\n    waiting: Set[CoroutineID] = set(),\n    first_result: Optional[CoroutineResult] = None,\n    errors: Dict[CoroutineID, Exception] = dict(),\n    generic_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.any() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.RaceFuture","title":"RaceFuture  <code>dataclass</code>","text":"<pre><code>RaceFuture(\n    waiting: Set[CoroutineID] = set(),\n    first_result: Optional[CoroutineResult] = None,\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.race() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.Coroutine","title":"Coroutine  <code>dataclass</code>","text":"<pre><code>Coroutine(\n    id: CoroutineID,\n    parent_id: Optional[CoroutineID],\n    coroutine: Union[DurableCoroutine, DurableGenerator],\n    result: Optional[Future] = None,\n)\n</code></pre> <p>An in-flight coroutine.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.State","title":"State  <code>dataclass</code>","text":"<pre><code>State(\n    version: str,\n    suspended: Dict[CoroutineID, Coroutine],\n    ready: List[Coroutine],\n    next_coroutine_id: int,\n    next_call_id: int,\n    prev_callers: List[Coroutine],\n    outstanding_calls: int,\n)\n</code></pre> <p>State of the scheduler and the coroutines it's managing.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.OneShotScheduler","title":"OneShotScheduler","text":"<pre><code>OneShotScheduler(\n    entry_point: Callable,\n    version: str = sys.version,\n    poll_min_results: int = 1,\n    poll_max_results: int = 10,\n    poll_max_wait_seconds: Optional[int] = None,\n)\n</code></pre> <p>Scheduler for local coroutines.</p> <p>It's a one-shot scheduler because it only runs one round of scheduling. When all local coroutines are suspended, the scheduler yields to Dispatch to take over scheduling asynchronous calls.</p> <p>Parameters:</p> Name Type Description Default <code>entry_point</code> <code>Callable</code> <p>Entry point for the main coroutine.</p> required <code>version</code> <code>str</code> <p>Version string to attach to scheduler/coroutine state. If the scheduler sees a version mismatch, it will respond to Dispatch with an INCOMPATIBLE_STATE status code.</p> <code>version</code> <code>poll_min_results</code> <code>int</code> <p>Minimum number of call results to wait for before coroutine execution should continue. Dispatch waits until this many results are available, or the poll_max_wait_seconds timeout is reached, whichever comes first.</p> <code>1</code> <code>poll_max_results</code> <code>int</code> <p>Maximum number of calls to receive from Dispatch per request.</p> <code>10</code> <code>poll_max_wait_seconds</code> <code>Optional[int]</code> <p>Maximum amount of time to suspend coroutines while waiting for call results. Optional.</p> <code>None</code>"},{"location":"reference/dispatch/status/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> status","text":""},{"location":"reference/dispatch/status/#dispatch.status","title":"status","text":""},{"location":"reference/dispatch/status/#dispatch.status.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_error","title":"status_for_error","text":"<pre><code>status_for_error(error: BaseException) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified error.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_output","title":"status_for_output","text":"<pre><code>status_for_output(output: Any) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified output value.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_error_type","title":"register_error_type","text":"<pre><code>register_error_type(\n    error_type: Type[Exception],\n    status_or_handler: Union[\n        Status, Callable[[Exception], Status]\n    ],\n)\n</code></pre> <p>Register an error type to Status mapping.</p> <p>The caller can either register a base exception and a handler, which derives a Status from errors of this type. Or, if there's only one exception to Status mapping to register, the caller can simply pass the exception class and the associated Status.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_output_type","title":"register_output_type","text":"<pre><code>register_output_type(\n    output_type: Type[Any],\n    status_or_handler: Union[\n        Status, Callable[[Any], Status]\n    ],\n)\n</code></pre> <p>Register an output type to Status mapping.</p> <p>The caller can either register a base class and a handler, which derives a Status from other classes of this type. Or, if there's only one output class to Status mapping to register, the caller can simply pass the class and the associated Status.</p>"},{"location":"reference/dispatch/test/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> test","text":""},{"location":"reference/dispatch/test/#dispatch.test","title":"test","text":""},{"location":"reference/dispatch/test/#dispatch.test.Registry","title":"Registry","text":"<pre><code>Registry(\n    name: str,\n    client: Optional[Client] = None,\n    endpoint: Optional[str] = None,\n)\n</code></pre> <p>Registry of functions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A unique name for the registry.</p> required <code>endpoint</code> <code>Optional[str]</code> <p>URL of the endpoint that the function is accessible from.</p> <code>None</code> <code>client</code> <code>Optional[Client]</code> <p>Client instance to use for dispatching calls to registered functions. Defaults to creating a new client instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/test/#dispatch.test.Registry.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the registry, removing it and all its functions from the dispatch application.</p>"},{"location":"reference/dispatch/test/#dispatch.test.Registry.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/test/#dispatch.test.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/test/#dispatch.test.Registry.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/test/#dispatch.test.main","title":"main  <code>async</code>","text":"<pre><code>main(coro: Coroutine[Any, Any, None]) -&gt; None\n</code></pre> <p>Entrypoint for dispatch function tests, which creates a local Dispatch server and runs the provided coroutine in the event loop of the server.</p> <p>This is a low-level primitive that most test programs wouldn't use directly, and instead would use one of the <code>function</code> or <code>method</code> decorators.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>Coroutine[Any, Any, None]</code> <p>The coroutine to run as the entrypoint, the function returns when the coroutine returns.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The value returned by the coroutine.</p>"},{"location":"reference/dispatch/test/#dispatch.test.run","title":"run","text":"<pre><code>run(coro: Coroutine[Any, Any, None]) -&gt; None\n</code></pre> <p>Runs the provided coroutine in the test server's event loop. This function is a convenience wrapper around the <code>main</code> function that runs the coroutine in the event loop of the test server.</p> <p>Programs typically don't use this function directly, unless they manage their own event loop. Most of the time, the <code>run</code> function is a more convenient way to run a dispatch application.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>Coroutine[Any, Any, None]</code> <p>The coroutine to run as the entrypoint, the function returns when the coroutine returns.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The value returned by the coroutine.</p>"},{"location":"reference/dispatch/test/#dispatch.test.function","title":"function","text":"<pre><code>function(\n    fn: Callable[[], Coroutine[Any, Any, None]]\n) -&gt; Callable[[], None]\n</code></pre> <p>This decorator is used to write tests that execute in a local Dispatch server.</p> <p>The decorated function would typically be a coroutine that implements the test and returns when the test is done, for example:</p> <pre><code>import dispatch\nimport dispatch.test\n\n@dispatch.function\ndef greet(name: str) -&gt; str:\n    return f\"Hello {name}!\"\n\n@dispatch.test.function\nasync def test_greet():\n    assert await greet(\"World\") == \"Hello World!\"\n</code></pre> <p>The test runs dispatch functions with the full dispatch capability, including retrying temporary errors, etc...</p>"},{"location":"reference/dispatch/test/#dispatch.test.method","title":"method","text":"<pre><code>method(\n    fn: Callable[[T], Coroutine[Any, Any, None]]\n) -&gt; Callable[[T], None]\n</code></pre> <p>This decorator is similar to the <code>function</code> decorator but is intended to apply to methods of a class (with a <code>self</code> value as first argument).</p>"},{"location":"reference/dispatch/asyncio/","title":"Index","text":""},{"location":"reference/dispatch/asyncio/#dispatch.asyncio","title":"asyncio","text":""},{"location":"reference/dispatch/asyncio/#dispatch.asyncio.Runner","title":"Runner","text":"<pre><code>Runner()\n</code></pre> <p>Runner is a class similar to asyncio.Runner but that we use for backward compatibility with Python 3.10 and earlier.</p>"},{"location":"reference/dispatch/asyncio/fastapi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fastapi","text":""},{"location":"reference/dispatch/asyncio/fastapi/#dispatch.asyncio.fastapi","title":"fastapi","text":"<p>Integration of Dispatch functions with FastAPI for handlers using asyncio.</p> <p>Example:</p> <pre><code>import fastapi\nfrom dispatch.asyncio.fastapi import Dispatch\n\napp = fastapi.FastAPI()\ndispatch = Dispatch(app)\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\nasync def read_root():\n    await my_function.dispatch()\n</code></pre>"},{"location":"reference/dispatch/asyncio/fastapi/#dispatch.asyncio.fastapi.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    app: FastAPI,\n    registry: Optional[Registry] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>             Bases: <code>AsyncFunctionService</code></p> <p>A Dispatch instance, powered by FastAPI.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app to configure.</p> required <code>registry</code> <code>Optional[Registry]</code> <p>A registry of functions to expose. If omitted, the default registry is used.</p> <code>None</code> <code>verification_key</code> <code>Optional[Union[Ed25519PublicKey, str, bytes]]</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable if omitted. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format. If not set, request signature verification is disabled (a warning will be logged by the constructor).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/asyncio/fastapi/#dispatch.asyncio.fastapi.Dispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/experimental/","title":"Index","text":""},{"location":"reference/dispatch/experimental/#dispatch.experimental","title":"experimental","text":""},{"location":"reference/dispatch/experimental/lambda_handler/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> lambda_handler","text":""},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler","title":"lambda_handler","text":"<p>Integration of Dispatch programmable endpoints for AWS Lambda.</p> <p>Example:</p> <pre><code>from dispatch.experimental.lambda_handler import Dispatch\n\ndispatch = Dispatch(api_key=\"test-key\")\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@dispatch.function\ndef entrypoint():\n    my_function()\n\ndef handler(event, context):\n    dispatch.handle(event, context, entrypoint=\"entrypoint\")\n</code></pre>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(registry: Optional[Registry] = None)\n</code></pre> <p>             Bases: <code>BlockingFunctionService</code></p>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Create a new batch.</p>"},{"location":"reference/dispatch/experimental/durable/","title":"Index","text":""},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable","title":"durable","text":"<p>A decorator that makes generators and coroutines serializable.</p> <p>This module defines a @durable decorator that can be applied to generator functions and async functions. The generator and coroutine instances they create can be pickled.</p> <p>Example usage:</p> <pre><code>import pickle\nfrom dispatch.experimental.durable import durable\n\n@durable\ndef my_generator():\n    for i in range(3):\n        yield i\n\n# Run the generator to its first yield point:\ng = my_generator()\nprint(next(g))  # 0\n\n# Make a copy, and consume the remaining items:\nb = pickle.dumps(g)\ng2 = pickle.loads(b)\nprint(next(g2))  # 1\nprint(next(g2))  # 2\n\n# The original is not affected:\nprint(next(g))  # 1\nprint(next(g))  # 2\n</code></pre>"},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable.durable","title":"durable","text":"<pre><code>durable(fn: Callable) -&gt; Callable\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p>"},{"location":"reference/dispatch/experimental/durable/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function","title":"function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableFunction","title":"DurableFunction","text":"<pre><code>DurableFunction(fn: FunctionType)\n</code></pre> <p>A wrapper for generator functions and async functions that make their generator and coroutine instances serializable.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.Serializable","title":"Serializable","text":"<pre><code>Serializable(\n    g: Union[GeneratorType, CoroutineType],\n    registered_fn: RegisteredFunction,\n    wrapped_coroutine: Union[DurableCoroutine, None],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>A wrapper for a generator or coroutine that makes it serializable.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableCoroutine","title":"DurableCoroutine","text":"<pre><code>DurableCoroutine(\n    coroutine: CoroutineType,\n    registered_fn: RegisteredFunction,\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Coroutine[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a coroutine that makes it serializable (can be pickled). Instances behave like the coroutines they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableGenerator","title":"DurableGenerator","text":"<pre><code>DurableGenerator(\n    generator: GeneratorType,\n    registered_fn: RegisteredFunction,\n    coroutine: Optional[DurableCoroutine],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Generator[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a generator that makes it serializable (can be pickled). Instances behave like the generators they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.durable","title":"durable","text":"<pre><code>durable(fn: Callable) -&gt; Callable\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p>"},{"location":"reference/dispatch/experimental/durable/registry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry","title":"registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.RegisteredFunction","title":"RegisteredFunction  <code>dataclass</code>","text":"<pre><code>RegisteredFunction(\n    fn: FunctionType,\n    key: str,\n    filename: str,\n    lineno: int,\n    hash: str,\n)\n</code></pre> <p>A function that can be referenced in durable state.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.register_function","title":"register_function","text":"<pre><code>register_function(fn: FunctionType) -&gt; RegisteredFunction\n</code></pre> <p>Register a function in the in-memory function registry.</p> <p>When serializing a registered function, a reference to the function is stored along with details about its location and contents. When deserializing the function, the registry is consulted in order to find the function associated with the reference (and in order to check whether the function is the same).</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to register.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>RegisteredFunction</code> <p>Unique identifier for the function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The function conflicts with another registered function.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.lookup_function","title":"lookup_function","text":"<pre><code>lookup_function(key: str) -&gt; RegisteredFunction\n</code></pre> <p>Lookup a registered function by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for the function.</p> required <p>Returns:</p> Name Type Description <code>RegisteredFunction</code> <code>RegisteredFunction</code> <p>the function that was registered with the specified key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>A function has not been registered with this key.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.unregister_function","title":"unregister_function","text":"<pre><code>unregister_function(key: str)\n</code></pre> <p>Unregister a function by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for the function.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>A function has not been registered with this key.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.clear_functions","title":"clear_functions","text":"<pre><code>clear_functions()\n</code></pre> <p>Clear functions clears the registry.</p>"},{"location":"reference/dispatch/integrations/","title":"Index","text":""},{"location":"reference/dispatch/integrations/#dispatch.integrations","title":"integrations","text":""},{"location":"reference/dispatch/integrations/http/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http","title":"http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http.http_response_code_status","title":"http_response_code_status","text":"<pre><code>http_response_code_status(code: int) -&gt; Status\n</code></pre> <p>Returns a Status that's broadly equivalent to an HTTP response status code.</p>"},{"location":"reference/dispatch/integrations/httpx/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> httpx","text":""},{"location":"reference/dispatch/integrations/httpx/#dispatch.integrations.httpx","title":"httpx","text":""},{"location":"reference/dispatch/integrations/openai/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openai","text":""},{"location":"reference/dispatch/integrations/openai/#dispatch.integrations.openai","title":"openai","text":""},{"location":"reference/dispatch/integrations/requests/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> requests","text":""},{"location":"reference/dispatch/integrations/requests/#dispatch.integrations.requests","title":"requests","text":""},{"location":"reference/dispatch/integrations/slack/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> slack","text":""},{"location":"reference/dispatch/integrations/slack/#dispatch.integrations.slack","title":"slack","text":""},{"location":"reference/dispatch/signature/","title":"Index","text":""},{"location":"reference/dispatch/signature/#dispatch.signature","title":"signature","text":""},{"location":"reference/dispatch/signature/#dispatch.signature.sign_request","title":"sign_request","text":"<pre><code>sign_request(\n    request: Request,\n    key: Ed25519PrivateKey,\n    created: datetime,\n)\n</code></pre> <p>Sign a request using HTTP Message Signatures.</p> <p>The function adds three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The signature covers the request method, the URL host and path, the Content-Type header, and the request body. At this time, an ED25519 signature is generated with a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to sign.</p> required <code>key</code> <code>Ed25519PrivateKey</code> <p>The Ed25519 private key to use to generate the signature.</p> required <code>created</code> <code>datetime</code> <p>The times at which the signature is created.</p> required"},{"location":"reference/dispatch/signature/#dispatch.signature.verify_request","title":"verify_request","text":"<pre><code>verify_request(\n    request: Request,\n    key: Ed25519PublicKey,\n    max_age: timedelta,\n)\n</code></pre> <p>Verify a request containing an HTTP Message Signature.</p> <p>The function checks three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The function checks signatures that cover at least the request method, the URL host and path, the Content-Type header, and the request body (via the Content-Digest header). At this time, signatures must use a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to verify.</p> required <code>key</code> <code>Ed25519PublicKey</code> <p>The Ed25519 public key to use to verify the signature.</p> required <code>max_age</code> <code>timedelta</code> <p>The maximum age of the signature.</p> required"},{"location":"reference/dispatch/signature/digest/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest","title":"digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.generate_content_digest","title":"generate_content_digest","text":"<pre><code>generate_content_digest(body: Union[str, bytes]) -&gt; str\n</code></pre> <p>Returns a SHA-512 Content-Digest header, according to https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13</p>"},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.verify_content_digest","title":"verify_content_digest","text":"<pre><code>verify_content_digest(\n    digest_header: Union[str, bytes],\n    body: Union[str, bytes],\n)\n</code></pre> <p>Verify a SHA-256 or SHA-512 Content-Digest header matches a request body.</p>"},{"location":"reference/dispatch/signature/key/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key","title":"key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.KeyResolver","title":"KeyResolver  <code>dataclass</code>","text":"<pre><code>KeyResolver(\n    key_id: str,\n    public_key: Optional[Ed25519PublicKey] = None,\n    private_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>             Bases: <code>HTTPSignatureKeyResolver</code></p> <p>KeyResolver provides public and private keys.</p> <p>At this time, multiple keys and/or key types are not supported. Keys must be Ed25519 keys and have an ID of DEFAULT_KEY_ID.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_pem","title":"public_key_from_pem","text":"<pre><code>public_key_from_pem(\n    pem: Union[str, bytes]\n) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key given a PEM representation.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_bytes","title":"public_key_from_bytes","text":"<pre><code>public_key_from_bytes(key: bytes) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_pem","title":"private_key_from_pem","text":"<pre><code>private_key_from_pem(\n    pem: Union[str, bytes], password: Optional[bytes] = None\n) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key given a PEM representation and optional password.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_bytes","title":"private_key_from_bytes","text":"<pre><code>private_key_from_bytes(key: bytes) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/request/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request","title":"request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(\n    method: str,\n    url: str,\n    headers: CaseInsensitiveDict,\n    body: Union[str, bytes],\n)\n</code></pre> <p>A framework-agnostic representation of an HTTP request.</p>"}]}