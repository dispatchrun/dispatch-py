{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Python SDK","text":"<p>This is the API reference for the Python SDK of Dispatch.</p> <ul> <li>Tutorials and guides: docs.stealthrocket.tech.</li> <li>Source: stealthrocket/dispatch-sdk.</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>The Dispatch SDK for Python.</p>"},{"location":"#dispatch.DispatchID","title":"<code>DispatchID: TypeAlias = str</code>  <code>module-attribute</code>","text":"<p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"#dispatch.Call","title":"<code>Call</code>  <code>dataclass</code>","text":"<p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@dataclass\nclass Call:\n    \"\"\"Instruction to call a function.\n\n    Though this class can be built manually, it is recommended to use the\n    with_call method of a Function instead.\n    \"\"\"\n\n    function: str\n    input: Any\n    endpoint: str | None = None\n    correlation_id: int | None = None\n\n    def _as_proto(self) -&gt; call_pb.Call:\n        input_bytes = _pb_any_pickle(self.input)\n        return call_pb.Call(\n            correlation_id=self.correlation_id,\n            endpoint=self.endpoint,\n            function=self.function,\n            input=input_bytes,\n        )\n</code></pre>"},{"location":"#dispatch.Client","title":"<code>Client</code>","text":"<p>Client for the Dispatch API.</p> Source code in <code>dispatch/client.py</code> <pre><code>class Client:\n    \"\"\"Client for the Dispatch API.\"\"\"\n\n    def __init__(self, api_key: None | str = None, api_url: None | str = None):\n        \"\"\"Create a new Dispatch client.\n\n        Args:\n            api_key: Dispatch API key to use for authentication. Uses the value of\n              the DISPATCH_API_KEY environment variable by default.\n\n            api_url: The URL of the Dispatch API to use. Uses the value of the\n              DISPATCH_API_URL environment variable if set, otherwise\n              defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n        Raises:\n            ValueError: if the API key is missing.\n        \"\"\"\n        if not api_key:\n            api_key = os.environ.get(\"DISPATCH_API_KEY\")\n        if not api_key:\n            raise ValueError(\"api_key is required\")\n\n        if not api_url:\n            api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n        if not api_url:\n            raise ValueError(\"api_url is required\")\n\n        self.api_url = api_url\n        self.api_key = api_key\n\n        self._init_stub()\n\n    def __getstate__(self):\n        return {\"api_url\": self.api_url, \"api_key\": self.api_key}\n\n    def __setstate__(self, state):\n        self.api_url = state[\"api_url\"]\n        self.api_key = state[\"api_key\"]\n        self._init_stub()\n\n    def _init_stub(self):\n        logger.debug(\"initializing client for Dispatch API at URL %s\", self.api_url)\n\n        result = urlparse(self.api_url)\n        match result.scheme:\n            case \"http\":\n                creds = grpc.local_channel_credentials()\n            case \"https\":\n                creds = grpc.ssl_channel_credentials()\n            case _:\n                raise ValueError(f\"Invalid API scheme: '{result.scheme}'\")\n\n        call_creds = grpc.access_token_call_credentials(self.api_key)\n        creds = grpc.composite_channel_credentials(creds, call_creds)\n        channel = grpc.secure_channel(result.netloc, creds)\n\n        self._stub = dispatch_grpc.DispatchServiceStub(channel)\n\n    def dispatch(self, calls: Iterable[Call]) -&gt; Iterable[DispatchID]:\n        \"\"\"Dispatch function calls.\n\n        Args:\n            calls: Calls to dispatch.\n\n        Returns:\n            Identifiers for the function calls, in the same order as the inputs.\n        \"\"\"\n        calls_proto = [c._as_proto() for c in calls]\n        logger.debug(\"dispatching %d function call(s)\", len(calls_proto))\n        req = dispatch_pb.DispatchRequest(calls=calls_proto)\n        resp = self._stub.Dispatch(req)\n        dispatch_ids = [DispatchID(x) for x in resp.dispatch_ids]\n        if logger.isEnabledFor(logging.DEBUG):\n            logger.debug(\n                \"dispatched %d function call(s): %s\",\n                len(calls_proto),\n                \", \".join(dispatch_ids),\n            )\n        return dispatch_ids\n</code></pre>"},{"location":"#dispatch.Client.__init__","title":"<code>__init__(api_key=None, api_url=None)</code>","text":"<p>Create a new Dispatch client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>None | str</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>None | str</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p> Source code in <code>dispatch/client.py</code> <pre><code>def __init__(self, api_key: None | str = None, api_url: None | str = None):\n    \"\"\"Create a new Dispatch client.\n\n    Args:\n        api_key: Dispatch API key to use for authentication. Uses the value of\n          the DISPATCH_API_KEY environment variable by default.\n\n        api_url: The URL of the Dispatch API to use. Uses the value of the\n          DISPATCH_API_URL environment variable if set, otherwise\n          defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n    Raises:\n        ValueError: if the API key is missing.\n    \"\"\"\n    if not api_key:\n        api_key = os.environ.get(\"DISPATCH_API_KEY\")\n    if not api_key:\n        raise ValueError(\"api_key is required\")\n\n    if not api_url:\n        api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n    if not api_url:\n        raise ValueError(\"api_url is required\")\n\n    self.api_url = api_url\n    self.api_key = api_key\n\n    self._init_stub()\n</code></pre>"},{"location":"#dispatch.Client.dispatch","title":"<code>dispatch(calls)</code>","text":"<p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>Iterable[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p> Source code in <code>dispatch/client.py</code> <pre><code>def dispatch(self, calls: Iterable[Call]) -&gt; Iterable[DispatchID]:\n    \"\"\"Dispatch function calls.\n\n    Args:\n        calls: Calls to dispatch.\n\n    Returns:\n        Identifiers for the function calls, in the same order as the inputs.\n    \"\"\"\n    calls_proto = [c._as_proto() for c in calls]\n    logger.debug(\"dispatching %d function call(s)\", len(calls_proto))\n    req = dispatch_pb.DispatchRequest(calls=calls_proto)\n    resp = self._stub.Dispatch(req)\n    dispatch_ids = [DispatchID(x) for x in resp.dispatch_ids]\n    if logger.isEnabledFor(logging.DEBUG):\n        logger.debug(\n            \"dispatched %d function call(s): %s\",\n            len(calls_proto),\n            \", \".join(dispatch_ids),\n        )\n    return dispatch_ids\n</code></pre>"},{"location":"#dispatch.Error","title":"<code>Error</code>","text":"<p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Error:\n    \"\"\"Error when running a function.\n\n    This is not a Python exception, but potentially part of a CallResult or\n    Output.\n    \"\"\"\n\n    def __init__(self, status: Status, type: str | None, message: str | None):\n        \"\"\"Create a new Error.\n\n        Args:\n            status: categorization of the error.\n            type: arbitrary string, used for humans. Optional.\n            message: arbitrary message. Optional.\n\n        Raises:\n            ValueError: Neither type or message was provided or status is\n              invalid.\n        \"\"\"\n        if type is None and message is None:\n            raise ValueError(\"At least one of type or message is required\")\n        if status is Status.OK:\n            raise ValueError(\"Status cannot be OK\")\n\n        self.type = type\n        self.message = message\n        self.status = status\n\n    @classmethod\n    def from_exception(cls, ex: Exception, status: Status | None = None) -&gt; Error:\n        \"\"\"Create an Error from a Python exception, using its class qualified\n        named as type.\n\n        The status tries to be inferred, but can be overriden. If it is not\n        provided or cannot be inferred, it defaults to TEMPORARY_ERROR.\n        \"\"\"\n\n        if status is None:\n            status = status_for_error(ex)\n\n        return Error(status, ex.__class__.__qualname__, str(ex))\n\n    @classmethod\n    def _from_proto(cls, proto: error_pb.Error) -&gt; Error:\n        return cls(Status.UNSPECIFIED, proto.type, proto.message)\n\n    def _as_proto(self) -&gt; error_pb.Error:\n        return error_pb.Error(type=self.type, message=self.message)\n</code></pre>"},{"location":"#dispatch.Error.__init__","title":"<code>__init__(status, type, message)</code>","text":"<p>Create a new Error.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str | None</code> <p>arbitrary string, used for humans. Optional.</p> required <code>message</code> <code>str | None</code> <p>arbitrary message. Optional.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p> Source code in <code>dispatch/proto.py</code> <pre><code>def __init__(self, status: Status, type: str | None, message: str | None):\n    \"\"\"Create a new Error.\n\n    Args:\n        status: categorization of the error.\n        type: arbitrary string, used for humans. Optional.\n        message: arbitrary message. Optional.\n\n    Raises:\n        ValueError: Neither type or message was provided or status is\n          invalid.\n    \"\"\"\n    if type is None and message is None:\n        raise ValueError(\"At least one of type or message is required\")\n    if status is Status.OK:\n        raise ValueError(\"Status cannot be OK\")\n\n    self.type = type\n    self.message = message\n    self.status = status\n</code></pre>"},{"location":"#dispatch.Error.from_exception","title":"<code>from_exception(ex, status=None)</code>  <code>classmethod</code>","text":"<p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overriden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef from_exception(cls, ex: Exception, status: Status | None = None) -&gt; Error:\n    \"\"\"Create an Error from a Python exception, using its class qualified\n    named as type.\n\n    The status tries to be inferred, but can be overriden. If it is not\n    provided or cannot be inferred, it defaults to TEMPORARY_ERROR.\n    \"\"\"\n\n    if status is None:\n        status = status_for_error(ex)\n\n    return Error(status, ex.__class__.__qualname__, str(ex))\n</code></pre>"},{"location":"#dispatch.Input","title":"<code>Input</code>","text":"<p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Input:\n    \"\"\"The input to a primitive function.\n\n    Functions always take a single argument of type Input. When the function is\n    run for the first time, it receives the input. When the function is a coroutine\n    that's resuming after a yield point, it receives the results of the yield\n    directive. Use the is_first_call and is_resume properties to differentiate\n    between the two cases.\n\n    This class is intended to be used as read-only.\n    \"\"\"\n\n    def __init__(self, req: function_pb.RunRequest):\n        self._has_input = req.HasField(\"input\")\n        if self._has_input:\n            input_pb = google.protobuf.wrappers_pb2.BytesValue()\n            req.input.Unpack(input_pb)\n            input_bytes = input_pb.value\n            self._input = pickle.loads(input_bytes)\n        else:\n            state_bytes = req.poll_result.coroutine_state\n            if len(state_bytes) &gt; 0:\n                self._coroutine_state = pickle.loads(state_bytes)\n            else:\n                self._coroutine_state = None\n            self._call_results = [\n                CallResult._from_proto(r) for r in req.poll_result.results\n            ]\n\n    @property\n    def is_first_call(self) -&gt; bool:\n        return self._has_input\n\n    @property\n    def is_resume(self) -&gt; bool:\n        return not self.is_first_call\n\n    @property\n    def input(self) -&gt; Any:\n        self._assert_first_call()\n        return self._input\n\n    def input_arguments(self) -&gt; tuple[list[Any], dict[str, Any]]:\n        \"\"\"Returns positional and keyword arguments carried by the input.\"\"\"\n        self._assert_first_call()\n        if not isinstance(self._input, _Arguments):\n            raise RuntimeError(\"input does not hold arguments\")\n        return self._input.args, self._input.kwargs\n\n    @property\n    def coroutine_state(self) -&gt; Any:\n        self._assert_resume()\n        return self._coroutine_state\n\n    @property\n    def call_results(self) -&gt; list[CallResult]:\n        self._assert_resume()\n        return self._call_results\n\n    def _assert_first_call(self):\n        if self.is_resume:\n            raise ValueError(\"This input is for a resumed coroutine\")\n\n    def _assert_resume(self):\n        if self.is_first_call:\n            raise ValueError(\"This input is for a first function call\")\n</code></pre>"},{"location":"#dispatch.Input.input_arguments","title":"<code>input_arguments()</code>","text":"<p>Returns positional and keyword arguments carried by the input.</p> Source code in <code>dispatch/proto.py</code> <pre><code>def input_arguments(self) -&gt; tuple[list[Any], dict[str, Any]]:\n    \"\"\"Returns positional and keyword arguments carried by the input.\"\"\"\n    self._assert_first_call()\n    if not isinstance(self._input, _Arguments):\n        raise RuntimeError(\"input does not hold arguments\")\n    return self._input.args, self._input.kwargs\n</code></pre>"},{"location":"#dispatch.Output","title":"<code>Output</code>","text":"<p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Output:\n    \"\"\"The output of a primitive function.\n\n    This class is meant to be instantiated and returned by authors of functions\n    to indicate the follow up action they need to take. Use the various class\n    methods create an instance of this class. For example Output.value() or\n    Output.poll().\n    \"\"\"\n\n    def __init__(self, proto: function_pb.RunResponse):\n        self._message = proto\n\n    @classmethod\n    def value(cls, value: Any, status: Status | None = None) -&gt; Output:\n        \"\"\"Terminally exit the function with the provided return value.\"\"\"\n        if status is None:\n            status = status_for_output(value)\n        return cls.exit(result=CallResult.from_value(value), status=status)\n\n    @classmethod\n    def error(cls, error: Error) -&gt; Output:\n        \"\"\"Terminally exit the function with the provided error.\"\"\"\n        return cls.exit(result=CallResult.from_error(error), status=error.status)\n\n    @classmethod\n    def tail_call(cls, tail_call: Call) -&gt; Output:\n        \"\"\"Terminally exit the function, and instruct the orchestrator to\n        tail call the specified function.\"\"\"\n        return cls.exit(tail_call=tail_call)\n\n    @classmethod\n    def exit(\n        cls,\n        result: CallResult | None = None,\n        tail_call: Call | None = None,\n        status: Status = Status.OK,\n    ) -&gt; Output:\n        \"\"\"Terminally exit the function.\"\"\"\n        result_proto = result._as_proto() if result else None\n        tail_call_proto = tail_call._as_proto() if tail_call else None\n        return Output(\n            function_pb.RunResponse(\n                status=status._proto,\n                exit=exit_pb.Exit(result=result_proto, tail_call=tail_call_proto),\n            )\n        )\n\n    @classmethod\n    def poll(cls, state: Any, calls: None | list[Call] = None) -&gt; Output:\n        \"\"\"Suspend the function with a set of Calls, instructing the\n        orchestrator to resume the function with the provided state when\n        call results are ready.\"\"\"\n        state_bytes = pickle.dumps(state)\n        poll = poll_pb.Poll(\n            coroutine_state=state_bytes,\n            # FIXME: make this configurable\n            max_results=1,\n            max_wait=duration_pb2.Duration(seconds=5),\n        )\n\n        if calls is not None:\n            for c in calls:\n                poll.calls.append(c._as_proto())\n\n        return Output(\n            function_pb.RunResponse(\n                status=status_pb.STATUS_OK,\n                poll=poll,\n            )\n        )\n</code></pre>"},{"location":"#dispatch.Output.error","title":"<code>error(error)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function with the provided error.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef error(cls, error: Error) -&gt; Output:\n    \"\"\"Terminally exit the function with the provided error.\"\"\"\n    return cls.exit(result=CallResult.from_error(error), status=error.status)\n</code></pre>"},{"location":"#dispatch.Output.exit","title":"<code>exit(result=None, tail_call=None, status=Status.OK)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef exit(\n    cls,\n    result: CallResult | None = None,\n    tail_call: Call | None = None,\n    status: Status = Status.OK,\n) -&gt; Output:\n    \"\"\"Terminally exit the function.\"\"\"\n    result_proto = result._as_proto() if result else None\n    tail_call_proto = tail_call._as_proto() if tail_call else None\n    return Output(\n        function_pb.RunResponse(\n            status=status._proto,\n            exit=exit_pb.Exit(result=result_proto, tail_call=tail_call_proto),\n        )\n    )\n</code></pre>"},{"location":"#dispatch.Output.poll","title":"<code>poll(state, calls=None)</code>  <code>classmethod</code>","text":"<p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef poll(cls, state: Any, calls: None | list[Call] = None) -&gt; Output:\n    \"\"\"Suspend the function with a set of Calls, instructing the\n    orchestrator to resume the function with the provided state when\n    call results are ready.\"\"\"\n    state_bytes = pickle.dumps(state)\n    poll = poll_pb.Poll(\n        coroutine_state=state_bytes,\n        # FIXME: make this configurable\n        max_results=1,\n        max_wait=duration_pb2.Duration(seconds=5),\n    )\n\n    if calls is not None:\n        for c in calls:\n            poll.calls.append(c._as_proto())\n\n    return Output(\n        function_pb.RunResponse(\n            status=status_pb.STATUS_OK,\n            poll=poll,\n        )\n    )\n</code></pre>"},{"location":"#dispatch.Output.tail_call","title":"<code>tail_call(tail_call)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef tail_call(cls, tail_call: Call) -&gt; Output:\n    \"\"\"Terminally exit the function, and instruct the orchestrator to\n    tail call the specified function.\"\"\"\n    return cls.exit(tail_call=tail_call)\n</code></pre>"},{"location":"#dispatch.Output.value","title":"<code>value(value, status=None)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function with the provided return value.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef value(cls, value: Any, status: Status | None = None) -&gt; Output:\n    \"\"\"Terminally exit the function with the provided return value.\"\"\"\n    if status is None:\n        status = status_for_output(value)\n    return cls.exit(result=CallResult.from_value(value), status=status)\n</code></pre>"},{"location":"#dispatch.Status","title":"<code>Status</code>","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p> Source code in <code>dispatch/status.py</code> <pre><code>@enum.unique\nclass Status(int, enum.Enum):\n    \"\"\"Enumeration of the possible values that can be used in the return status\n    of functions.\n    \"\"\"\n\n    UNSPECIFIED = status_pb.STATUS_UNSPECIFIED\n    OK = status_pb.STATUS_OK\n    TIMEOUT = status_pb.STATUS_TIMEOUT\n    THROTTLED = status_pb.STATUS_THROTTLED\n    INVALID_ARGUMENT = status_pb.STATUS_INVALID_ARGUMENT\n    INVALID_RESPONSE = status_pb.STATUS_INVALID_RESPONSE\n    TEMPORARY_ERROR = status_pb.STATUS_TEMPORARY_ERROR\n    PERMANENT_ERROR = status_pb.STATUS_PERMANENT_ERROR\n    INCOMPATIBLE_STATE = status_pb.STATUS_INCOMPATIBLE_STATE\n\n    _proto: status_pb.Status\n</code></pre>"},{"location":"#dispatch.client","title":"<code>client</code>","text":""},{"location":"#dispatch.client.Client","title":"<code>Client</code>","text":"<p>Client for the Dispatch API.</p> Source code in <code>dispatch/client.py</code> <pre><code>class Client:\n    \"\"\"Client for the Dispatch API.\"\"\"\n\n    def __init__(self, api_key: None | str = None, api_url: None | str = None):\n        \"\"\"Create a new Dispatch client.\n\n        Args:\n            api_key: Dispatch API key to use for authentication. Uses the value of\n              the DISPATCH_API_KEY environment variable by default.\n\n            api_url: The URL of the Dispatch API to use. Uses the value of the\n              DISPATCH_API_URL environment variable if set, otherwise\n              defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n        Raises:\n            ValueError: if the API key is missing.\n        \"\"\"\n        if not api_key:\n            api_key = os.environ.get(\"DISPATCH_API_KEY\")\n        if not api_key:\n            raise ValueError(\"api_key is required\")\n\n        if not api_url:\n            api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n        if not api_url:\n            raise ValueError(\"api_url is required\")\n\n        self.api_url = api_url\n        self.api_key = api_key\n\n        self._init_stub()\n\n    def __getstate__(self):\n        return {\"api_url\": self.api_url, \"api_key\": self.api_key}\n\n    def __setstate__(self, state):\n        self.api_url = state[\"api_url\"]\n        self.api_key = state[\"api_key\"]\n        self._init_stub()\n\n    def _init_stub(self):\n        logger.debug(\"initializing client for Dispatch API at URL %s\", self.api_url)\n\n        result = urlparse(self.api_url)\n        match result.scheme:\n            case \"http\":\n                creds = grpc.local_channel_credentials()\n            case \"https\":\n                creds = grpc.ssl_channel_credentials()\n            case _:\n                raise ValueError(f\"Invalid API scheme: '{result.scheme}'\")\n\n        call_creds = grpc.access_token_call_credentials(self.api_key)\n        creds = grpc.composite_channel_credentials(creds, call_creds)\n        channel = grpc.secure_channel(result.netloc, creds)\n\n        self._stub = dispatch_grpc.DispatchServiceStub(channel)\n\n    def dispatch(self, calls: Iterable[Call]) -&gt; Iterable[DispatchID]:\n        \"\"\"Dispatch function calls.\n\n        Args:\n            calls: Calls to dispatch.\n\n        Returns:\n            Identifiers for the function calls, in the same order as the inputs.\n        \"\"\"\n        calls_proto = [c._as_proto() for c in calls]\n        logger.debug(\"dispatching %d function call(s)\", len(calls_proto))\n        req = dispatch_pb.DispatchRequest(calls=calls_proto)\n        resp = self._stub.Dispatch(req)\n        dispatch_ids = [DispatchID(x) for x in resp.dispatch_ids]\n        if logger.isEnabledFor(logging.DEBUG):\n            logger.debug(\n                \"dispatched %d function call(s): %s\",\n                len(calls_proto),\n                \", \".join(dispatch_ids),\n            )\n        return dispatch_ids\n</code></pre>"},{"location":"#dispatch.client.Client.__init__","title":"<code>__init__(api_key=None, api_url=None)</code>","text":"<p>Create a new Dispatch client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>None | str</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>None | str</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p> Source code in <code>dispatch/client.py</code> <pre><code>def __init__(self, api_key: None | str = None, api_url: None | str = None):\n    \"\"\"Create a new Dispatch client.\n\n    Args:\n        api_key: Dispatch API key to use for authentication. Uses the value of\n          the DISPATCH_API_KEY environment variable by default.\n\n        api_url: The URL of the Dispatch API to use. Uses the value of the\n          DISPATCH_API_URL environment variable if set, otherwise\n          defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n    Raises:\n        ValueError: if the API key is missing.\n    \"\"\"\n    if not api_key:\n        api_key = os.environ.get(\"DISPATCH_API_KEY\")\n    if not api_key:\n        raise ValueError(\"api_key is required\")\n\n    if not api_url:\n        api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n    if not api_url:\n        raise ValueError(\"api_url is required\")\n\n    self.api_url = api_url\n    self.api_key = api_key\n\n    self._init_stub()\n</code></pre>"},{"location":"#dispatch.client.Client.dispatch","title":"<code>dispatch(calls)</code>","text":"<p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>Iterable[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p> Source code in <code>dispatch/client.py</code> <pre><code>def dispatch(self, calls: Iterable[Call]) -&gt; Iterable[DispatchID]:\n    \"\"\"Dispatch function calls.\n\n    Args:\n        calls: Calls to dispatch.\n\n    Returns:\n        Identifiers for the function calls, in the same order as the inputs.\n    \"\"\"\n    calls_proto = [c._as_proto() for c in calls]\n    logger.debug(\"dispatching %d function call(s)\", len(calls_proto))\n    req = dispatch_pb.DispatchRequest(calls=calls_proto)\n    resp = self._stub.Dispatch(req)\n    dispatch_ids = [DispatchID(x) for x in resp.dispatch_ids]\n    if logger.isEnabledFor(logging.DEBUG):\n        logger.debug(\n            \"dispatched %d function call(s): %s\",\n            len(calls_proto),\n            \", \".join(dispatch_ids),\n        )\n    return dispatch_ids\n</code></pre>"},{"location":"#dispatch.coroutine","title":"<code>coroutine</code>","text":""},{"location":"#dispatch.coroutine.Directive","title":"<code>Directive</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Directives instruct the Dispatch orchestrator.</p> Source code in <code>dispatch/coroutine.py</code> <pre><code>class Directive(enum.Enum):\n    \"\"\"Directives instruct the Dispatch orchestrator.\"\"\"\n\n    EXIT = 0\n    POLL = 1\n</code></pre>"},{"location":"#dispatch.coroutine.InvalidContextError","title":"<code>InvalidContextError</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>A directive was used outside a @dispatch.coroutine.</p> Source code in <code>dispatch/coroutine.py</code> <pre><code>class InvalidContextError(RuntimeError):\n    \"\"\"A directive was used outside a @dispatch.coroutine.\"\"\"\n</code></pre>"},{"location":"#dispatch.experimental","title":"<code>experimental</code>","text":""},{"location":"#dispatch.experimental.durable","title":"<code>durable</code>","text":"<p>A decorator that makes generators and coroutines serializable.</p> <p>This module defines a @durable decorator that can be applied to generator functions and async functions. The generator and coroutine instances they create can be pickled.</p> <p>Example usage:</p> <pre><code>import pickle\nfrom dispatch.experimental.durable import durable\n\n@durable\ndef my_generator():\n    for i in range(3):\n        yield i\n\n# Run the generator to its first yield point:\ng = my_generator()\nprint(next(g))  # 0\n\n# Make a copy, and consume the remaining items:\nb = pickle.dumps(g)\ng2 = pickle.loads(b)\nprint(next(g2))  # 1\nprint(next(g2))  # 2\n\n# The original is not affected:\nprint(next(g))  # 1\nprint(next(g))  # 2\n</code></pre>"},{"location":"#dispatch.experimental.durable.durable","title":"<code>durable(fn)</code>","text":"<p>Returns a \"durable\" function that creates serializable generators or coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <p>A generator function or async function.</p> required Source code in <code>dispatch/experimental/durable/function.py</code> <pre><code>def durable(fn) -&gt; DurableFunction:\n    \"\"\"Returns a \"durable\" function that creates serializable\n    generators or coroutines.\n\n    Args:\n        fn: A generator function or async function.\n    \"\"\"\n    return DurableFunction(fn)\n</code></pre>"},{"location":"#dispatch.experimental.durable.frame","title":"<code>frame</code>","text":""},{"location":"#dispatch.experimental.durable.frame.__file__","title":"<code>__file__ = '/opt/hostedtoolcache/Python/3.11.8/x64/lib/python3.11/site-packages/dispatch/experimental/durable/frame.cpython-311-x86_64-linux-gnu.so'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"#dispatch.experimental.durable.frame.__name__","title":"<code>__name__ = 'dispatch.experimental.durable.frame'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"#dispatch.experimental.durable.frame.__package__","title":"<code>__package__ = 'dispatch.experimental.durable'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"#dispatch.experimental.durable.frame.get_frame_ip","title":"<code>get_frame_ip()</code>  <code>builtin</code>","text":"<p>Get instruction pointer of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.get_frame_sp","title":"<code>get_frame_sp()</code>  <code>builtin</code>","text":"<p>Get stack pointer of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.get_frame_stack_at","title":"<code>get_frame_stack_at()</code>  <code>builtin</code>","text":"<p>Get an object from a generator or coroutine's stack, as an (is_null, obj) tuple.</p>"},{"location":"#dispatch.experimental.durable.frame.get_frame_state","title":"<code>get_frame_state()</code>  <code>builtin</code>","text":"<p>Get frame state of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.set_frame_ip","title":"<code>set_frame_ip()</code>  <code>builtin</code>","text":"<p>Set instruction pointer of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.set_frame_sp","title":"<code>set_frame_sp()</code>  <code>builtin</code>","text":"<p>Set stack pointer of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.set_frame_stack_at","title":"<code>set_frame_stack_at()</code>  <code>builtin</code>","text":"<p>Set or unset an object on the stack of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.frame.set_frame_state","title":"<code>set_frame_state()</code>  <code>builtin</code>","text":"<p>Set frame state of a generator or coroutine.</p>"},{"location":"#dispatch.experimental.durable.function","title":"<code>function</code>","text":""},{"location":"#dispatch.experimental.durable.function.DurableCoroutine","title":"<code>DurableCoroutine</code>","text":"<p>             Bases: <code>Serializable</code>, <code>Coroutine[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a coroutine that makes it serializable (can be pickled). Instances behave like the coroutines they wrap.</p> Source code in <code>dispatch/experimental/durable/function.py</code> <pre><code>class DurableCoroutine(Serializable, Coroutine[_YieldT, _SendT, _ReturnT]):\n    \"\"\"A wrapper for a coroutine that makes it serializable (can be pickled).\n    Instances behave like the coroutines they wrap.\"\"\"\n\n    def __init__(\n        self,\n        coroutine: CoroutineType,\n        registered_fn: RegisteredFunction,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        self.coroutine = coroutine\n        Serializable.__init__(self, coroutine, registered_fn, *args, **kwargs)\n\n    def __await__(self) -&gt; Generator[Any, None, _ReturnT]:\n        coroutine_wrapper = self.coroutine.__await__()\n        generator = cast(GeneratorType, coroutine_wrapper)\n        durable_coroutine_wrapper: Generator[Any, None, _ReturnT] = DurableGenerator(\n            generator, self.registered_fn, *self.args, coro_await=True, **self.kwargs\n        )\n        return durable_coroutine_wrapper\n\n    def send(self, send: _SendT) -&gt; _YieldT:\n        return self.coroutine.send(send)\n\n    def throw(self, typ, val=None, tb: TracebackType | None = None) -&gt; _YieldT:\n        return self.coroutine.throw(typ, val, tb)\n\n    def close(self) -&gt; None:\n        self.coroutine.close()\n\n    def __setstate__(self, state):\n        Serializable.__setstate__(self, state)\n        self.coroutine = cast(CoroutineType, self.g)\n\n    @property\n    def cr_running(self) -&gt; bool:\n        return self.coroutine.cr_running\n\n    @property\n    def cr_suspended(self) -&gt; bool:\n        return self.coroutine.cr_suspended\n\n    @property\n    def cr_code(self) -&gt; CodeType:\n        return self.coroutine.cr_code\n\n    @property\n    def cr_frame(self) -&gt; FrameType:\n        return self.coroutine.cr_frame\n\n    @property\n    def cr_await(self) -&gt; Any | None:\n        return self.coroutine.cr_await\n\n    @property\n    def cr_origin(self) -&gt; tuple[tuple[str, int, str], ...] | None:\n        return self.coroutine.cr_origin\n</code></pre>"},{"location":"#dispatch.experimental.durable.function.DurableFunction","title":"<code>DurableFunction</code>","text":"<p>A wrapper for generator functions and async functions that make their generator and coroutine instances serializable.</p> Source code in <code>dispatch/experimental/durable/function.py</code> <pre><code>class DurableFunction:\n    \"\"\"A wrapper for generator functions and async functions that make\n    their generator and coroutine instances serializable.\"\"\"\n\n    def __init__(self, fn: FunctionType):\n        self.registered_fn = register_function(fn)\n\n    def __call__(self, *args, **kwargs):\n        result = self.registered_fn.fn(*args, **kwargs)\n\n        if isinstance(result, GeneratorType):\n            return DurableGenerator(result, self.registered_fn, *args, **kwargs)\n        elif isinstance(result, CoroutineType):\n            return DurableCoroutine(result, self.registered_fn, *args, **kwargs)\n        elif isinstance(result, AsyncGeneratorType):\n            raise NotImplementedError(\n                \"only synchronous generator functions are supported at this time\"\n            )\n        else:\n            raise ValueError(\n                \"@durable function did not return a generator or coroutine\"\n            )\n\n    @property\n    def __name__(self):\n        return self.registered_fn.fn.__name__\n</code></pre>"},{"location":"#dispatch.experimental.durable.function.DurableGenerator","title":"<code>DurableGenerator</code>","text":"<p>             Bases: <code>Serializable</code>, <code>Generator[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a generator that makes it serializable (can be pickled). Instances behave like the generators they wrap.</p> Source code in <code>dispatch/experimental/durable/function.py</code> <pre><code>class DurableGenerator(Serializable, Generator[_YieldT, _SendT, _ReturnT]):\n    \"\"\"A wrapper for a generator that makes it serializable (can be pickled).\n    Instances behave like the generators they wrap.\"\"\"\n\n    def __init__(\n        self,\n        generator: GeneratorType,\n        registered_fn: RegisteredFunction,\n        *args: Any,\n        coro_await: bool = False,\n        **kwargs: Any,\n    ):\n        self.generator = generator\n        Serializable.__init__(\n            self, generator, registered_fn, *args, coro_await=coro_await, **kwargs\n        )\n\n    def __iter__(self) -&gt; Generator[_YieldT, _SendT, _ReturnT]:\n        return self\n\n    def __next__(self) -&gt; _YieldT:\n        return next(self.generator)\n\n    def send(self, send: _SendT) -&gt; _YieldT:\n        return self.generator.send(send)\n\n    def throw(self, typ, val=None, tb: TracebackType | None = None) -&gt; _YieldT:\n        return self.generator.throw(typ, val, tb)\n\n    def close(self) -&gt; None:\n        self.generator.close()\n\n    def __setstate__(self, state):\n        Serializable.__setstate__(self, state)\n        self.generator = cast(GeneratorType, self.g)\n\n    @property\n    def gi_running(self) -&gt; bool:\n        return self.generator.gi_running\n\n    @property\n    def gi_suspended(self) -&gt; bool:\n        return self.generator.gi_suspended\n\n    @property\n    def gi_code(self) -&gt; CodeType:\n        return self.generator.gi_code\n\n    @property\n    def gi_frame(self) -&gt; FrameType:\n        return self.generator.gi_frame\n\n    @property\n    def gi_yieldfrom(self) -&gt; GeneratorType | None:\n        return self.generator.gi_yieldfrom\n</code></pre>"},{"location":"#dispatch.experimental.durable.function.durable","title":"<code>durable(fn)</code>","text":"<p>Returns a \"durable\" function that creates serializable generators or coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <p>A generator function or async function.</p> required Source code in <code>dispatch/experimental/durable/function.py</code> <pre><code>def durable(fn) -&gt; DurableFunction:\n    \"\"\"Returns a \"durable\" function that creates serializable\n    generators or coroutines.\n\n    Args:\n        fn: A generator function or async function.\n    \"\"\"\n    return DurableFunction(fn)\n</code></pre>"},{"location":"#dispatch.experimental.durable.registry","title":"<code>registry</code>","text":""},{"location":"#dispatch.experimental.durable.registry.RegisteredFunction","title":"<code>RegisteredFunction</code>  <code>dataclass</code>","text":"<p>A function that can be referenced in durable state.</p> Source code in <code>dispatch/experimental/durable/registry.py</code> <pre><code>@dataclass\nclass RegisteredFunction:\n    \"\"\"A function that can be referenced in durable state.\"\"\"\n\n    key: str\n    fn: FunctionType\n    filename: str\n    lineno: int\n    hash: str\n</code></pre>"},{"location":"#dispatch.experimental.durable.registry.lookup_function","title":"<code>lookup_function(key)</code>","text":"<p>Lookup a registered function by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for the function.</p> required <p>Returns:</p> Name Type Description <code>RegisteredFunction</code> <code>RegisteredFunction</code> <p>the function that was registered with the specified key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>A function has not been registered with this key.</p> Source code in <code>dispatch/experimental/durable/registry.py</code> <pre><code>def lookup_function(key: str) -&gt; RegisteredFunction:\n    \"\"\"Lookup a registered function by key.\n\n    Args:\n        key: Unique identifier for the function.\n\n    Returns:\n        RegisteredFunction: the function that was registered with the specified key.\n\n    Raises:\n        KeyError: A function has not been registered with this key.\n    \"\"\"\n    return _REGISTRY[key]\n</code></pre>"},{"location":"#dispatch.experimental.durable.registry.register_function","title":"<code>register_function(fn)</code>","text":"<p>Register a function in the in-memory function registry.</p> <p>When serializing a registered function, a reference to the function is stored along with details about its location and contents. When deserializing the function, the registry is consulted in order to find the function associated with the reference (and in order to check whether the function is the same).</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to register.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>RegisteredFunction</code> <p>Unique identifier for the function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The function conflicts with another registered function.</p> Source code in <code>dispatch/experimental/durable/registry.py</code> <pre><code>def register_function(fn: FunctionType) -&gt; RegisteredFunction:\n    \"\"\"Register a function in the in-memory function registry.\n\n    When serializing a registered function, a reference to the function\n    is stored along with details about its location and contents. When\n    deserializing the function, the registry is consulted in order to\n    find the function associated with the reference (and in order to\n    check whether the function is the same).\n\n    Args:\n        fn: The function to register.\n\n    Returns:\n        str: Unique identifier for the function.\n\n    Raises:\n        ValueError: The function conflicts with another registered function.\n    \"\"\"\n    code = fn.__code__\n    key = code.co_qualname\n    if key in _REGISTRY:\n        raise ValueError(f\"durable function already registered with key {key}\")\n\n    filename = code.co_filename\n    lineno = code.co_firstlineno\n    code_hash = \"sha256:\" + hashlib.sha256(code.co_code).hexdigest()\n\n    wrapper = RegisteredFunction(\n        key=key, fn=fn, filename=filename, lineno=lineno, hash=code_hash\n    )\n\n    _REGISTRY[key] = wrapper\n    return wrapper\n</code></pre>"},{"location":"#dispatch.experimental.durable.serializable","title":"<code>serializable</code>","text":""},{"location":"#dispatch.experimental.durable.serializable.Serializable","title":"<code>Serializable</code>","text":"<p>A wrapper for a generator or coroutine that makes it serializable.</p> Source code in <code>dispatch/experimental/durable/serializable.py</code> <pre><code>class Serializable:\n    \"\"\"A wrapper for a generator or coroutine that makes it serializable.\"\"\"\n\n    g: GeneratorType | CoroutineType\n    registered_fn: RegisteredFunction\n    coro_await: bool\n    args: list[Any]\n    kwargs: dict[str, Any]\n\n    def __init__(\n        self,\n        g: GeneratorType | CoroutineType,\n        registered_fn: RegisteredFunction,\n        *args: Any,\n        coro_await: bool = False,\n        **kwargs: Any,\n    ):\n        self.g = g\n        self.registered_fn = registered_fn\n        self.coro_await = coro_await\n        self.args = list(args)\n        self.kwargs = kwargs\n\n    def __getstate__(self):\n        g = self.g\n        rfn = self.registered_fn\n\n        # Capture the details necessary to recreate the generator.\n        ip = ext.get_frame_ip(g)\n        sp = ext.get_frame_sp(g)\n        frame_state = ext.get_frame_state(g)\n        stack = [ext.get_frame_stack_at(g, i) for i in range(ext.get_frame_sp(g))]\n\n        if TRACE:\n            typ = \"GENERATOR\" if isinstance(g, GeneratorType) else \"COROUTINE\"\n            print(f\"\\n[DURABLE] {typ} STATE ({rfn.key}):\")\n            print(f\"function = {rfn.fn.__qualname__} ({rfn.filename}:{rfn.lineno})\")\n            print(f\"code hash = {rfn.hash}\")\n            print(f\"args = {self.args}\")\n            print(f\"kwargs = {self.kwargs}\")\n            print(f\"coro await = {self.coro_await}\")\n            print(f\"IP = {ip}\")\n            print(f\"SP = {sp}\")\n            print(f\"frame state = {frame_state}\")\n            for i, (is_null, value) in enumerate(stack):\n                if is_null:\n                    print(f\"stack[{i}] = NULL\")\n                else:\n                    print(f\"stack[{i}] = {value}\")\n            print()\n\n        state = {\n            \"function\": {\n                \"key\": rfn.key,\n                \"filename\": rfn.filename,\n                \"lineno\": rfn.lineno,\n                \"hash\": rfn.hash,\n                \"coro_await\": self.coro_await,\n                \"args\": self.args,\n                \"kwargs\": self.kwargs,\n            },\n            \"frame\": {\n                \"ip\": ip,\n                \"sp\": sp,\n                \"stack\": stack,\n                \"state\": frame_state,\n            },\n        }\n        return state\n\n    def __setstate__(self, state):\n        function_state = state[\"function\"]\n        frame_state = state[\"frame\"]\n\n        # Recreate the generator/coroutine by looking up the constructor\n        # and calling it with the same args/kwargs.\n        key, filename, lineno, code_hash, args, kwargs, coro_await = (\n            function_state[\"key\"],\n            function_state[\"filename\"],\n            function_state[\"lineno\"],\n            function_state[\"hash\"],\n            function_state[\"args\"],\n            function_state[\"kwargs\"],\n            function_state[\"coro_await\"],\n        )\n\n        rfn = lookup_function(key)\n        if filename != rfn.filename or lineno != rfn.lineno:\n            raise ValueError(\n                f\"location mismatch for function {key}: {filename}:{lineno} vs. expected {rfn.filename}:{rfn.lineno}\"\n            )\n        elif code_hash != rfn.hash:\n            raise ValueError(\n                f\"hash mismatch for function {key}: {code_hash} vs. expected {rfn.hash}\"\n            )\n\n        g = rfn.fn(*args, **kwargs)\n\n        if coro_await:\n            g = g.__await__()\n\n        # Restore the frame state (stack + stack pointer + instruction pointer).\n        ext.set_frame_ip(g, frame_state[\"ip\"])\n        ext.set_frame_sp(g, frame_state[\"sp\"])\n        for i, (is_null, obj) in enumerate(frame_state[\"stack\"]):\n            ext.set_frame_stack_at(g, i, is_null, obj)\n        ext.set_frame_state(g, frame_state[\"state\"])\n\n        self.g = g\n        self.registered_fn = rfn\n        self.coro_await = coro_await\n        self.args = args\n        self.kwargs = kwargs\n</code></pre>"},{"location":"#dispatch.experimental.multicolor","title":"<code>multicolor</code>","text":""},{"location":"#dispatch.experimental.multicolor.CustomYield","title":"<code>CustomYield</code>  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a function marked with @yields.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Any</code> <p>The type of yield that was specified in the @yields decorator.</p> <code>args</code> <code>list[Any]</code> <p>Positional arguments to the function call.</p> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to the function call.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>@dataclass\nclass CustomYield(YieldType):\n    \"\"\"A yield from a function marked with @yields.\n\n    Attributes:\n        type: The type of yield that was specified in the @yields decorator.\n        args: Positional arguments to the function call.\n        kwargs: Keyword arguments to the function call.\n    \"\"\"\n\n    type: Any\n    args: list[Any]\n    kwargs: dict[str, Any] | None = None\n\n    def kwarg(self, name, pos) -&gt; Any:\n        if self.kwargs is None:\n            return self.args[pos]\n        try:\n            return self.kwargs[name]\n        except KeyError:\n            return self.args[pos]\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.GeneratorYield","title":"<code>GeneratorYield</code>  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a generator.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The value that was yielded from the generator.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>@dataclass\nclass GeneratorYield(YieldType):\n    \"\"\"A yield from a generator.\n\n    Attributes:\n        value: The value that was yielded from the generator.\n    \"\"\"\n\n    value: Any = None\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.NoSourceError","title":"<code>NoSourceError</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Function source code is not available.</p> Source code in <code>dispatch/experimental/multicolor/parse.py</code> <pre><code>class NoSourceError(RuntimeError):\n    \"\"\"Function source code is not available.\"\"\"\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.compile_function","title":"<code>compile_function(fn, decorator=None, cache_key='default')</code>","text":"<p>Compile a regular function into a generator that yields data passed to functions marked with the @multicolor.yields decorator. Decorated yield functions can be called from anywhere in the call stack, and functions in between do not have to be generators or async functions (coroutines).</p> <p>Example:</p> <pre><code>@multicolor.yields(type=\"sleep\")\ndef sleep(seconds): ...\n\ndef parent():\n    sleep(3)  # yield point\n\ndef grandparent():\n    parent()\n\ncompiled_grandparent = multicolor.compile_function(grandparent)\ngenerator = compiled_grandparent()\nfor item in generator:\n    print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n</code></pre> <p>Two-way data flow works as expected. At a yield point, generator.send(value) can be used to send data back to the yield point and to resume execution. The data sent back will be the return value of the function decorated with @multicolor.yields:</p> <pre><code>@multicolor.yields(type=\"add\")\ndef add(a: int, b: int) -&gt; int:\n    return a + b  # default/synchronous implementation\n\ndef scheduler(generator):\n    try:\n        send = None\n        while True:\n            item = generator.send(send)\n            match item:\n                case multicolor.CustomYield(type=\"add\"):\n                    a, b = item.args\n                    print(f\"adding {a} + {b}\")\n                    send = a + b\n    except StopIteration as e:\n        return e.value  # return value\n\ndef adder(a: int, b: int) -&gt; int:\n    return add(a, b)\n\ncompiled_adder = multicolor.compile_function(adder)\ngenerator = compiled_adder(1, 2)\nresult = scheduler(generator)\nprint(result) # 3\n</code></pre> <p>The @multicolor.yields decorator does not change the implementation of the function it decorates. If the function is run without being compiled, the default implementation will be used instead:</p> <pre><code>print(adder(1, 2))  # 3\n</code></pre> <p>The default implementation could also raise an error, to ensure that the function is only ever called from a compiled function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to compile.</p> required <code>decorator</code> <p>An optional decorator to apply to the compiled function.</p> <code>None</code> <code>cache_key</code> <code>str</code> <p>Cache key to use when caching compiled functions.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>FunctionType</code> <code>FunctionType | MethodType</code> <p>A compiled generator function.</p> Source code in <code>dispatch/experimental/multicolor/compile.py</code> <pre><code>def compile_function(\n    fn: FunctionType, decorator=None, cache_key: str = \"default\"\n) -&gt; FunctionType | MethodType:\n    \"\"\"Compile a regular function into a generator that yields data passed\n    to functions marked with the @multicolor.yields decorator. Decorated yield\n    functions can be called from anywhere in the call stack, and functions\n    in between do not have to be generators or async functions (coroutines).\n\n    Example:\n\n        @multicolor.yields(type=\"sleep\")\n        def sleep(seconds): ...\n\n        def parent():\n            sleep(3)  # yield point\n\n        def grandparent():\n            parent()\n\n        compiled_grandparent = multicolor.compile_function(grandparent)\n        generator = compiled_grandparent()\n        for item in generator:\n            print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n\n    Two-way data flow works as expected. At a yield point, generator.send(value)\n    can be used to send data back to the yield point and to resume execution.\n    The data sent back will be the return value of the function decorated with\n    @multicolor.yields:\n\n        @multicolor.yields(type=\"add\")\n        def add(a: int, b: int) -&gt; int:\n            return a + b  # default/synchronous implementation\n\n        def scheduler(generator):\n            try:\n                send = None\n                while True:\n                    item = generator.send(send)\n                    match item:\n                        case multicolor.CustomYield(type=\"add\"):\n                            a, b = item.args\n                            print(f\"adding {a} + {b}\")\n                            send = a + b\n            except StopIteration as e:\n                return e.value  # return value\n\n        def adder(a: int, b: int) -&gt; int:\n            return add(a, b)\n\n        compiled_adder = multicolor.compile_function(adder)\n        generator = compiled_adder(1, 2)\n        result = scheduler(generator)\n        print(result) # 3\n\n    The @multicolor.yields decorator does not change the implementation of\n    the function it decorates. If the function is run without being\n    compiled, the default implementation will be used instead:\n\n        print(adder(1, 2))  # 3\n\n    The default implementation could also raise an error, to ensure that\n    the function is only ever called from a compiled function.\n\n    Args:\n        fn: The function to compile.\n        decorator: An optional decorator to apply to the compiled function.\n        cache_key: Cache key to use when caching compiled functions.\n\n    Returns:\n        FunctionType: A compiled generator function.\n    \"\"\"\n    compiled_fn, _ = _compile_internal(fn, decorator, cache_key)\n    return compiled_fn\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.no_yields","title":"<code>no_yields(fn)</code>","text":"<p>Decorator that hints that a function (and anything called recursively) does not yield.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>def no_yields(fn):\n    \"\"\"Decorator that hints that a function (and anything called\n    recursively) does not yield.\"\"\"\n    fn._multicolor_no_yields = True  # type: ignore[attr-defined]\n    return fn\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.compile","title":"<code>compile</code>","text":""},{"location":"#dispatch.experimental.multicolor.compile.CallTransformer","title":"<code>CallTransformer</code>","text":"<p>             Bases: <code>NodeTransformer</code></p> <p>Replace explicit function calls with a gadget that recursively compiles functions into generators and then replaces the function call with a yield from.</p> <p>The transformations are only valid for ASTs that have passed through the desugaring pass; only ast.Expr(value=ast.Call(...)) and ast.Assign(targets=..., value=ast.Call(..)) nodes are transformed here.</p> Source code in <code>dispatch/experimental/multicolor/compile.py</code> <pre><code>class CallTransformer(ast.NodeTransformer):\n    \"\"\"Replace explicit function calls with a gadget that recursively compiles\n    functions into generators and then replaces the function call with a\n    yield from.\n\n    The transformations are only valid for ASTs that have passed through the\n    desugaring pass; only ast.Expr(value=ast.Call(...)) and\n    ast.Assign(targets=..., value=ast.Call(..)) nodes are transformed here.\n    \"\"\"\n\n    def visit_Assign(self, node: ast.Assign) -&gt; ast.stmt:\n        if not isinstance(node.value, ast.Call):\n            return node\n        assign_stmt = ast.Assign(targets=node.targets)\n        return self._build_call_gadget(node.value, assign_stmt)\n\n    def visit_Expr(self, node: ast.Expr) -&gt; ast.stmt:\n        if not isinstance(node.value, ast.Call):\n            return node\n        return self._build_call_gadget(node.value)\n\n    def _build_call_gadget(\n        self, fn_call: ast.Call, assign: ast.Assign | None = None\n    ) -&gt; ast.stmt:\n        fn = fn_call.func\n        args = ast.List(elts=fn_call.args, ctx=ast.Load())\n        if fn_call.keywords:\n            kwargs: ast.expr = ast.Call(\n                func=ast.Name(id=\"dict\", ctx=ast.Load()),\n                args=[],\n                keywords=fn_call.keywords,\n            )\n        else:\n            kwargs = ast.Constant(value=None)\n\n        compiled_fn = ast.Name(id=\"_multicolor_compiled_fn\", ctx=ast.Store())\n        compiled_fn_call = ast.Call(\n            func=ast.Name(id=\"_multicolor_compiled_fn\", ctx=ast.Load()),\n            args=fn_call.args,\n            keywords=fn_call.keywords,\n        )\n\n        if assign:\n            assign.value = ast.Name(id=\"_multicolor_result\", ctx=ast.Load())\n            assign_result: ast.stmt = assign\n        else:\n            assign_result = ast.Pass()\n\n        result = rewrite_template(\n            \"\"\"\n            if hasattr(__fn__, \"_multicolor_yield_type\"):\n                _multicolor_result = yield _multicolor_custom_yield(type=__fn__._multicolor_yield_type, args=__args__, kwargs=__kwargs__)\n                __assign_result__\n            elif hasattr(__fn__, \"_multicolor_no_yields\"):\n                _multicolor_result = __fn_call__\n                __assign_result__\n            else:\n                _multicolor_result = None\n                try:\n                    if isinstance(__fn__, type):\n                        raise _multicolor_no_source_error # FIXME: this bypasses compilation for calls that are actually class instantiations\n                    __compiled_fn__, _multicolor_color = _multicolor_compile(__fn__, _multicolor_decorator, _multicolor_cache_key)\n                except _multicolor_no_source_error:\n                    _multicolor_result = __fn_call__\n                else:\n                    _multicolor_generator = __compiled_fn_call__\n                    if _multicolor_color == _multicolor_generator_color:\n                        _multicolor_result = []\n                        for _multicolor_yield in _multicolor_generator:\n                            if isinstance(_multicolor_yield, _multicolor_generator_yield):\n                                _multicolor_result.append(_multicolor_yield.value)\n                            else:\n                                yield _multicolor_yield\n                    else:\n                        _multicolor_result = yield from _multicolor_generator\n                finally:\n                    __assign_result__\n            \"\"\",\n            __fn__=fn,\n            __fn_call__=fn_call,\n            __args__=args,\n            __kwargs__=kwargs,\n            __compiled_fn__=compiled_fn,\n            __compiled_fn_call__=compiled_fn_call,\n            __assign_result__=assign_result,\n        )\n\n        return result[0]\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.compile.FunctionColor","title":"<code>FunctionColor</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Color (aka. type/flavor) of a function.</p> <p>There are four colors of functions in Python: * regular (e.g. def fn(): pass) * generator (e.g. def fn(): yield) * async (e.g. async def fn(): pass) * async generator (e.g. async def fn(): yield)</p> <p>Only the first two colors are supported at this time.</p> Source code in <code>dispatch/experimental/multicolor/compile.py</code> <pre><code>class FunctionColor(Enum):\n    \"\"\"Color (aka. type/flavor) of a function.\n\n    There are four colors of functions in Python:\n    * regular (e.g. def fn(): pass)\n    * generator (e.g. def fn(): yield)\n    * async (e.g. async def fn(): pass)\n    * async generator (e.g. async def fn(): yield)\n\n    Only the first two colors are supported at this time.\n    \"\"\"\n\n    REGULAR_FUNCTION = 0\n    GENERATOR_FUNCTION = 1\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.compile.GeneratorTransformer","title":"<code>GeneratorTransformer</code>","text":"<p>             Bases: <code>NodeTransformer</code></p> <p>Wrap ast.Yield values in a GeneratorYield container.</p> Source code in <code>dispatch/experimental/multicolor/compile.py</code> <pre><code>class GeneratorTransformer(ast.NodeTransformer):\n    \"\"\"Wrap ast.Yield values in a GeneratorYield container.\"\"\"\n\n    def visit_Yield(self, node: ast.Yield) -&gt; ast.Yield:\n        value = node.value\n        if node.value is None:\n            value = ast.Constant(value=None)\n\n        wrapped_value = ast.Call(\n            func=ast.Name(id=\"_multicolor_generator_yield\", ctx=ast.Load()),\n            args=[],\n            keywords=[ast.keyword(arg=\"value\", value=value)],\n        )\n        return ast.Yield(value=wrapped_value)\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.compile.compile_function","title":"<code>compile_function(fn, decorator=None, cache_key='default')</code>","text":"<p>Compile a regular function into a generator that yields data passed to functions marked with the @multicolor.yields decorator. Decorated yield functions can be called from anywhere in the call stack, and functions in between do not have to be generators or async functions (coroutines).</p> <p>Example:</p> <pre><code>@multicolor.yields(type=\"sleep\")\ndef sleep(seconds): ...\n\ndef parent():\n    sleep(3)  # yield point\n\ndef grandparent():\n    parent()\n\ncompiled_grandparent = multicolor.compile_function(grandparent)\ngenerator = compiled_grandparent()\nfor item in generator:\n    print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n</code></pre> <p>Two-way data flow works as expected. At a yield point, generator.send(value) can be used to send data back to the yield point and to resume execution. The data sent back will be the return value of the function decorated with @multicolor.yields:</p> <pre><code>@multicolor.yields(type=\"add\")\ndef add(a: int, b: int) -&gt; int:\n    return a + b  # default/synchronous implementation\n\ndef scheduler(generator):\n    try:\n        send = None\n        while True:\n            item = generator.send(send)\n            match item:\n                case multicolor.CustomYield(type=\"add\"):\n                    a, b = item.args\n                    print(f\"adding {a} + {b}\")\n                    send = a + b\n    except StopIteration as e:\n        return e.value  # return value\n\ndef adder(a: int, b: int) -&gt; int:\n    return add(a, b)\n\ncompiled_adder = multicolor.compile_function(adder)\ngenerator = compiled_adder(1, 2)\nresult = scheduler(generator)\nprint(result) # 3\n</code></pre> <p>The @multicolor.yields decorator does not change the implementation of the function it decorates. If the function is run without being compiled, the default implementation will be used instead:</p> <pre><code>print(adder(1, 2))  # 3\n</code></pre> <p>The default implementation could also raise an error, to ensure that the function is only ever called from a compiled function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to compile.</p> required <code>decorator</code> <p>An optional decorator to apply to the compiled function.</p> <code>None</code> <code>cache_key</code> <code>str</code> <p>Cache key to use when caching compiled functions.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>FunctionType</code> <code>FunctionType | MethodType</code> <p>A compiled generator function.</p> Source code in <code>dispatch/experimental/multicolor/compile.py</code> <pre><code>def compile_function(\n    fn: FunctionType, decorator=None, cache_key: str = \"default\"\n) -&gt; FunctionType | MethodType:\n    \"\"\"Compile a regular function into a generator that yields data passed\n    to functions marked with the @multicolor.yields decorator. Decorated yield\n    functions can be called from anywhere in the call stack, and functions\n    in between do not have to be generators or async functions (coroutines).\n\n    Example:\n\n        @multicolor.yields(type=\"sleep\")\n        def sleep(seconds): ...\n\n        def parent():\n            sleep(3)  # yield point\n\n        def grandparent():\n            parent()\n\n        compiled_grandparent = multicolor.compile_function(grandparent)\n        generator = compiled_grandparent()\n        for item in generator:\n            print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n\n    Two-way data flow works as expected. At a yield point, generator.send(value)\n    can be used to send data back to the yield point and to resume execution.\n    The data sent back will be the return value of the function decorated with\n    @multicolor.yields:\n\n        @multicolor.yields(type=\"add\")\n        def add(a: int, b: int) -&gt; int:\n            return a + b  # default/synchronous implementation\n\n        def scheduler(generator):\n            try:\n                send = None\n                while True:\n                    item = generator.send(send)\n                    match item:\n                        case multicolor.CustomYield(type=\"add\"):\n                            a, b = item.args\n                            print(f\"adding {a} + {b}\")\n                            send = a + b\n            except StopIteration as e:\n                return e.value  # return value\n\n        def adder(a: int, b: int) -&gt; int:\n            return add(a, b)\n\n        compiled_adder = multicolor.compile_function(adder)\n        generator = compiled_adder(1, 2)\n        result = scheduler(generator)\n        print(result) # 3\n\n    The @multicolor.yields decorator does not change the implementation of\n    the function it decorates. If the function is run without being\n    compiled, the default implementation will be used instead:\n\n        print(adder(1, 2))  # 3\n\n    The default implementation could also raise an error, to ensure that\n    the function is only ever called from a compiled function.\n\n    Args:\n        fn: The function to compile.\n        decorator: An optional decorator to apply to the compiled function.\n        cache_key: Cache key to use when caching compiled functions.\n\n    Returns:\n        FunctionType: A compiled generator function.\n    \"\"\"\n    compiled_fn, _ = _compile_internal(fn, decorator, cache_key)\n    return compiled_fn\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.desugar","title":"<code>desugar</code>","text":""},{"location":"#dispatch.experimental.multicolor.desugar.Desugar","title":"<code>Desugar</code>","text":"<p>The desugar pass simplifies subsequent AST transformations that need to replace an expression (e.g. a function call) with a statement (e.g. an if branch) in a function definition.</p> <p>The pass recursively simplifies control flow and compound expressions in a function definition such that: - expressions that are children of statements either have no children, or   only have children of type ast.Name and/or ast.Constant - those parent expressions are either part of an ast.Expr(value=expr)   statement or an ast.Assign(value=expr) statement</p> <p>The pass does not recurse into lambda expressions, or nested function or class definitions.</p> Source code in <code>dispatch/experimental/multicolor/desugar.py</code> <pre><code>class Desugar:\n    \"\"\"The desugar pass simplifies subsequent AST transformations that need\n    to replace an expression (e.g. a function call) with a statement (e.g. an\n    if branch) in a function definition.\n\n    The pass recursively simplifies control flow and compound expressions\n    in a function definition such that:\n    - expressions that are children of statements either have no children, or\n      only have children of type ast.Name and/or ast.Constant\n    - those parent expressions are either part of an ast.Expr(value=expr)\n      statement or an ast.Assign(value=expr) statement\n\n    The pass does not recurse into lambda expressions, or nested function or\n    class definitions.\n    \"\"\"\n\n    def __init__(self):\n        self.name_count = 0\n\n    def desugar(self, stmts: list[ast.stmt]) -&gt; list[ast.stmt]:\n        return self._desugar_stmts(stmts)\n\n    def _desugar_stmt(self, stmt: ast.stmt) -&gt; tuple[ast.stmt, list[ast.stmt]]:\n        deps: list[ast.stmt] = []\n        match stmt:\n            # Pass\n            case ast.Pass():\n                pass\n\n            # Break\n            case ast.Break():\n                pass\n\n            # Continue\n            case ast.Continue():\n                pass\n\n            # Import(alias* names)\n            case ast.Import():\n                pass\n\n            # ImportFrom(identifier? module, alias* names, int? level)\n            case ast.ImportFrom():\n                pass\n\n            # Nonlocal(identifier* names)\n            case ast.Nonlocal():\n                pass\n\n            # Global(identifier* names)\n            case ast.Global():\n                pass\n\n            # Return(expr? value)\n            case ast.Return():\n                if stmt.value is not None:\n                    stmt.value, deps = self._desugar_expr(stmt.value)\n\n            # Expr(expr value)\n            case ast.Expr():\n                stmt.value, deps = self._desugar_expr(stmt.value, expr_stmt=True)\n\n            # Assert(expr test, expr? msg)\n            case ast.Assert():\n                stmt.test, deps = self._desugar_expr(stmt.test)\n                if stmt.msg is not None:\n                    stmt.msg, msg_deps = self._desugar_expr(stmt.msg)\n                    deps.extend(msg_deps)\n\n            # Assign(expr* targets, expr value, string? type_comment)\n            case ast.Assign():\n                stmt.targets, deps = self._desugar_exprs(stmt.targets)\n                stmt.value, value_deps = self._desugar_expr(stmt.value)\n                deps.extend(value_deps)\n\n            # AugAssign(expr target, operator op, expr value)\n            case ast.AugAssign():\n                target = cast(\n                    ast.expr, stmt.target\n                )  # ast.Name | ast.Attribute | ast.Subscript\n                target, deps = self._desugar_expr(target)\n                stmt.target = cast(ast.Name | ast.Attribute | ast.Subscript, target)\n                stmt.value, value_deps = self._desugar_expr(stmt.value)\n                deps.extend(value_deps)\n\n            # AnnAssign(expr target, expr annotation, expr? value, int simple)\n            case ast.AnnAssign():\n                target = cast(\n                    ast.expr, stmt.target\n                )  # ast.Name | ast.Attribute | ast.Subscript\n                target, deps = self._desugar_expr(target)\n                stmt.target = cast(ast.Name | ast.Attribute | ast.Subscript, target)\n                stmt.annotation, annotation_deps = self._desugar_expr(stmt.annotation)\n                deps.extend(annotation_deps)\n                if stmt.value is not None:\n                    stmt.value, value_deps = self._desugar_expr(stmt.value)\n                    deps.extend(value_deps)\n\n            # Delete(expr* targets)\n            case ast.Delete():\n                stmt.targets, deps = self._desugar_exprs(stmt.targets, del_stmt=True)\n\n            # Raise(expr? exc, expr? cause)\n            case ast.Raise():\n                if stmt.exc is not None:\n                    stmt.exc, exc_deps = self._desugar_expr(stmt.exc)\n                    deps.extend(exc_deps)\n                if stmt.cause is not None:\n                    stmt.cause, cause_deps = self._desugar_expr(stmt.cause)\n                    deps.extend(cause_deps)\n\n            # If(expr test, stmt* body, stmt* orelse)\n            case ast.If():\n                stmt.test, deps = self._desugar_expr(stmt.test)\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n\n            # While(expr test, stmt* body, stmt* orelse)\n            case ast.While():\n                stmt.test, deps = self._desugar_expr(stmt.test)\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n\n            # For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n            case ast.For():\n                stmt.target, deps = self._desugar_expr(stmt.target)\n                stmt.iter, iter_deps = self._desugar_expr(stmt.iter)\n                deps.extend(iter_deps)\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n\n            # AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n            case ast.AsyncFor():\n                stmt.target, deps = self._desugar_expr(stmt.target)\n                stmt.iter, iter_deps = self._desugar_expr(stmt.iter)\n                deps.extend(iter_deps)\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n\n            # Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n            case ast.Try():\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.handlers, deps = self._desugar_except_handlers(stmt.handlers)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n                stmt.finalbody = self._desugar_stmts(stmt.finalbody)\n\n            # TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n            case ast.TryStar():\n                stmt.body = self._desugar_stmts(stmt.body)\n                stmt.handlers, deps = self._desugar_except_handlers(stmt.handlers)\n                stmt.orelse = self._desugar_stmts(stmt.orelse)\n                stmt.finalbody = self._desugar_stmts(stmt.finalbody)\n\n            # Match(expr subject, match_case* cases)\n            case ast.Match():\n                stmt.subject, deps = self._desugar_expr(stmt.subject)\n                stmt.cases, match_case_deps = self._desugar_match_cases(stmt.cases)\n                deps.extend(match_case_deps)\n\n            # With(withitem* items, stmt* body, string? type_comment)\n            case ast.With():\n                while len(stmt.items) &gt; 1:\n                    last = stmt.items.pop()\n                    stmt.body = [ast.With(items=[last], body=stmt.body)]\n\n                stmt.items, deps = self._desugar_withitems(stmt.items)\n                stmt.body = self._desugar_stmts(stmt.body)\n\n            # AsyncWith(withitem* items, stmt* body, string? type_comment)\n            case ast.AsyncWith():\n                while len(stmt.items) &gt; 1:\n                    last = stmt.items.pop()\n                    stmt.body = [ast.AsyncWith(items=[last], body=stmt.body)]\n\n                stmt.items, deps = self._desugar_withitems(stmt.items)\n                stmt.body = self._desugar_stmts(stmt.body)\n\n            # FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)\n            case ast.FunctionDef():\n                pass  # do not recurse\n\n            # AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)\n            case ast.AsyncFunctionDef():\n                pass  # do not recurse\n\n            # ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)\n            case ast.ClassDef():\n                pass  # do not recurse\n\n            case _:\n                raise NotImplementedError(f\"desugar {stmt}\")\n\n        return stmt, deps\n\n    def _desugar_expr(\n        self, expr: ast.expr, expr_stmt=False, del_stmt=False\n    ) -&gt; tuple[ast.expr, list[ast.stmt]]:\n        # These cases have no nested expressions or statements. Return\n        # early so that no superfluous temporaries are generated.\n        if isinstance(expr, ast.Name):\n            # Name(identifier id, expr_context ctx)\n            return expr, []\n        elif isinstance(expr, ast.Constant):\n            # Constant(constant value, string? kind)\n            return expr, []\n        elif isinstance(expr, ast.Attribute) and isinstance(expr.value, ast.Name):\n            # Attribute(expr value, identifier attr, expr_context ctx)\n            return expr, []\n\n        deps: list[ast.stmt] = []\n        wrapper = None\n        create_temporary = not expr_stmt and not del_stmt\n        is_store = False\n        match expr:\n            # Call(expr func, expr* args, keyword* keywords)\n            case ast.Call():\n                expr.func, deps = self._desugar_expr(expr.func)\n                expr.args, args_deps = self._desugar_exprs(expr.args)\n                deps.extend(args_deps)\n                expr.keywords, keywords_deps = self._desugar_keywords(expr.keywords)\n                deps.extend(keywords_deps)\n\n            # BinOp(expr left, operator op, expr right)\n            case ast.BinOp():\n                expr.left, deps = self._desugar_expr(expr.left)\n                expr.right, right_deps = self._desugar_expr(expr.right)\n                deps.extend(right_deps)\n\n            # UnaryOp(unaryop op, expr operand)\n            case ast.UnaryOp():\n                expr.operand, deps = self._desugar_expr(expr.operand)\n\n            # BoolOp(boolop op, expr* values)\n            case ast.BoolOp():\n                expr.values, deps = self._desugar_exprs(expr.values)\n\n            # Tuple(expr* elts, expr_context ctx)\n            case ast.Tuple():\n                expr.elts, deps = self._desugar_exprs(expr.elts)\n                is_store = isinstance(expr.ctx, ast.Store)\n\n            # List(expr* elts, expr_context ctx)\n            case ast.List():\n                expr.elts, deps = self._desugar_exprs(expr.elts)\n                is_store = isinstance(expr.ctx, ast.Store)\n\n            # Set(expr* elts)\n            case ast.Set():\n                expr.elts, deps = self._desugar_exprs(expr.elts)\n\n            # Dict(expr* keys, expr* values)\n            case ast.Dict():\n                for i, key in enumerate(expr.keys):\n                    if key is not None:\n                        key, key_deps = self._desugar_expr(key)\n                        deps.extend(key_deps)\n                    expr.keys[i] = key\n                expr.values, values_deps = self._desugar_exprs(expr.values)\n                deps.extend(values_deps)\n\n            # Starred(expr value, expr_context ctx)\n            case ast.Starred():\n                expr.value, deps = self._desugar_expr(expr.value)\n                is_store = isinstance(expr.ctx, ast.Store)\n                create_temporary = False\n\n            # Compare(expr left, cmpop* ops, expr* comparators)\n            case ast.Compare():\n                expr.left, deps = self._desugar_expr(expr.left)\n                expr.comparators, comparators_deps = self._desugar_exprs(\n                    expr.comparators\n                )\n                deps.extend(comparators_deps)\n\n            # NamedExpr(expr target, expr value)\n            case ast.NamedExpr():\n                target = cast(ast.expr, expr.target)  # ast.Name\n                target, deps = self._desugar_expr(target)\n                expr.target = cast(ast.Name, target)\n                expr.value, value_deps = self._desugar_expr(expr.value)\n                deps.extend(value_deps)\n\n                # We need to preserve the assignment so that the target is accessible\n                # from subsequent expressions/statements. ast.NamedExpr isn't valid as\n                # a standalone a statement, so we need to convert to ast.Assign.\n                deps.append(ast.Assign(targets=[expr.target], value=expr.value))\n                expr = expr.target\n\n            # Lambda(arguments args, expr body)\n            case ast.Lambda():\n                pass  # do not recurse\n\n            # Await(expr value)\n            case ast.Await():\n                expr.value, deps = self._desugar_expr(expr.value)\n\n            # Yield(expr? value)\n            case ast.Yield():\n                if expr.value is not None:\n                    expr.value, deps = self._desugar_expr(expr.value)\n\n            # YieldFrom(expr value)\n            case ast.YieldFrom():\n                expr.value, deps = self._desugar_expr(expr.value)\n\n            # JoinedStr(expr* values)\n            case ast.JoinedStr():\n                expr.values, deps = self._desugar_exprs(expr.values)\n\n            # FormattedValue(expr value, int conversion, expr? format_spec)\n            case ast.FormattedValue():\n                expr.value, deps = self._desugar_expr(expr.value)\n                # Note: expr.format_spec is an expression, but we do not expect to\n                # find compound expressions there.\n\n                conversion = expr.conversion\n                format_spec = expr.format_spec\n                expr = expr.value\n                create_temporary = False\n\n                def wrapper(value):\n                    return ast.FormattedValue(\n                        value=value, conversion=conversion, format_spec=format_spec\n                    )\n\n            # Attribute(expr value, identifier attr, expr_context ctx)\n            case ast.Attribute():\n                expr.value, deps = self._desugar_expr(expr.value)\n                is_store = isinstance(expr.ctx, ast.Store)\n\n            # Subscript(expr value, expr slice, expr_context ctx)\n            case ast.Subscript():\n                expr.value, deps = self._desugar_expr(expr.value)\n                expr.slice, slice_deps = self._desugar_expr(expr.slice)\n                deps.extend(slice_deps)\n                is_store = isinstance(expr.ctx, ast.Store)\n\n            # Slice(expr? lower, expr? upper, expr? step)\n            case ast.Slice():\n                if expr.lower is not None:\n                    expr.lower, lower_deps = self._desugar_expr(expr.lower)\n                    deps.extend(lower_deps)\n                if expr.upper is not None:\n                    expr.upper, upper_deps = self._desugar_expr(expr.upper)\n                    deps.extend(upper_deps)\n                if expr.step is not None:\n                    expr.step, step_deps = self._desugar_expr(expr.step)\n                    deps.extend(step_deps)\n                is_store = True\n\n            # IfExp(expr test, expr body, expr orelse)\n            case ast.IfExp():\n                tmp = self._new_name()\n                if_stmt, deps = self._desugar_stmt(\n                    ast.If(\n                        test=expr.test,\n                        body=[\n                            ast.Assign(\n                                targets=[ast.Name(id=tmp, ctx=ast.Store())],\n                                value=expr.body,\n                            )\n                        ],\n                        orelse=[\n                            ast.Assign(\n                                targets=[ast.Name(id=tmp, ctx=ast.Store())],\n                                value=expr.orelse,\n                            )\n                        ],\n                    )\n                )\n                deps.append(if_stmt)\n                expr = ast.Name(id=tmp, ctx=ast.Load())\n                create_temporary = False\n\n            # ListComp(expr elt, comprehension* generators)\n            case ast.ListComp():\n                tmp = self._new_name()\n\n                deps = [\n                    ast.Assign(\n                        targets=[ast.Name(id=tmp, ctx=ast.Store())],\n                        value=ast.List(elts=[], ctx=ast.Load()),\n                    )\n                ]\n\n                inner_statement: ast.stmt = ast.Expr(\n                    value=ast.Call(\n                        func=ast.Attribute(\n                            value=ast.Name(id=tmp, ctx=ast.Load()),\n                            attr=\"append\",\n                            ctx=ast.Load(),\n                        ),\n                        args=[expr.elt],\n                        keywords=[],\n                    )\n                )\n\n                deps += self._desugar_comprehensions(expr.generators, inner_statement)\n                expr = ast.Name(id=tmp, ctx=ast.Load())\n                create_temporary = False\n\n            # SetComp(expr elt, comprehension* generators)\n            case ast.SetComp():\n                tmp = self._new_name()\n\n                deps = [\n                    ast.Assign(\n                        targets=[ast.Name(id=tmp, ctx=ast.Store())],\n                        value=ast.Call(\n                            func=ast.Name(id=\"set\", ctx=ast.Load()),\n                            args=[],\n                            keywords=[],\n                        ),\n                    )\n                ]\n\n                inner_statement = ast.Expr(\n                    value=ast.Call(\n                        func=ast.Attribute(\n                            value=ast.Name(id=tmp, ctx=ast.Load()),\n                            attr=\"add\",\n                            ctx=ast.Load(),\n                        ),\n                        args=[expr.elt],\n                        keywords=[],\n                    )\n                )\n\n                deps += self._desugar_comprehensions(expr.generators, inner_statement)\n                expr = ast.Name(id=tmp, ctx=ast.Load())\n                create_temporary = False\n\n            # DictComp(expr key, expr value, comprehension* generators)\n            case ast.DictComp():\n                tmp = self._new_name()\n\n                deps = [\n                    ast.Assign(\n                        targets=[ast.Name(id=tmp, ctx=ast.Store())],\n                        value=ast.Dict(keys=[], values=[]),\n                    )\n                ]\n\n                inner_statement = ast.Assign(\n                    targets=[\n                        ast.Subscript(\n                            value=ast.Name(id=tmp, ctx=ast.Store()),\n                            slice=expr.key,\n                            ctx=ast.Store(),\n                        )\n                    ],\n                    value=expr.value,\n                )\n\n                deps += self._desugar_comprehensions(expr.generators, inner_statement)\n                expr = ast.Name(id=tmp, ctx=ast.Load())\n                create_temporary = False\n\n            # GeneratorExp(expr elt, comprehension* generators)\n            case ast.GeneratorExp():\n                tmp = self._new_name()\n                inner_statement = ast.Expr(value=ast.Yield(value=expr.elt))\n                body = self._desugar_comprehensions(expr.generators, inner_statement)\n                deps = [\n                    ast.FunctionDef(\n                        name=tmp,\n                        args=ast.arguments(\n                            args=[],\n                            posonlyargs=[],\n                            kwonlyargs=[],\n                            kw_defaults=[],\n                            defaults=[],\n                        ),\n                        body=body,\n                        decorator_list=[],\n                    )\n                ]\n                expr = ast.Call(\n                    func=ast.Name(id=tmp, ctx=ast.Load()), args=[], keywords=[]\n                )\n\n            case _:\n                raise NotImplementedError(f\"desugar {expr}\")\n\n        if create_temporary and not is_store:\n            tmp = self._new_name()\n            deps.append(\n                ast.Assign(targets=[ast.Name(id=tmp, ctx=ast.Store())], value=expr)\n            )\n            expr = ast.Name(id=tmp, ctx=ast.Load())\n\n        if wrapper is not None:\n            expr = wrapper(expr)\n\n        return expr, deps\n\n    def _desugar_stmts(self, stmts: list[ast.stmt]) -&gt; list[ast.stmt]:\n        desugared = []\n        for stmt in stmts:\n            stmt, deps = self._desugar_stmt(stmt)\n            desugared.extend(deps)\n            desugared.append(stmt)\n        return desugared\n\n    def _desugar_exprs(\n        self, exprs: list[ast.expr], del_stmt=False\n    ) -&gt; tuple[list[ast.expr], list[ast.stmt]]:\n        desugared = []\n        deps = []\n        for expr in exprs:\n            expr, expr_deps = self._desugar_expr(expr, del_stmt=del_stmt)\n            deps.extend(expr_deps)\n            desugared.append(expr)\n        return desugared, deps\n\n    def _desugar_keywords(\n        self, keywords: list[ast.keyword]\n    ) -&gt; tuple[list[ast.keyword], list[ast.stmt]]:\n        # keyword(identifier? arg, expr value)\n        desugared = []\n        deps = []\n        for keyword in keywords:\n            keyword.value, keyword_deps = self._desugar_expr(keyword.value)\n            deps.extend(keyword_deps)\n            desugared.append(keyword)\n        return desugared, deps\n\n    def _desugar_except_handlers(\n        self, handlers: list[ast.ExceptHandler]\n    ) -&gt; tuple[list[ast.ExceptHandler], list[ast.stmt]]:\n        # excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n        desugared = []\n        deps: list[ast.stmt] = []\n        for handler in handlers:\n            if handler.type is not None:\n                # FIXME: exception type exprs need special handling. Each handler's\n                #  type expr is evaluated one at a time until there's a match. The\n                #  remaining handler's type exprs are not evaluated.\n                # handler.type, type_deps = self._desugar_expr(handler.type)\n                # deps.extend(type_deps)\n                pass\n            handler.body = self._desugar_stmts(handler.body)\n            desugared.append(handler)\n        return desugared, deps\n\n    def _desugar_match_cases(\n        self, cases: list[ast.match_case]\n    ) -&gt; tuple[list[ast.match_case], list[ast.stmt]]:\n        # match_case(pattern pattern, expr? guard, stmt* body)\n        desugared: list[ast.match_case] = []\n        deps: list[ast.stmt] = []\n        for case in cases:\n            if case.guard is not None:\n                # FIXME: match guards need special handling; they shouldn't be evaluated\n                #  unless the pattern matches.\n                # case.guard, guard_deps = self._desugar_expr(case.guard)\n                # deps.extend(guard_deps)\n                pass\n            case.body = self._desugar_stmts(case.body)\n            desugared.append(case)\n            # You're supposed to be able to pass the AST root to this function\n            # to have it repair (fill in missing) line numbers and such. It\n            # seems there's a bug where it doesn't recurse into match cases.\n            # Work around the issue by manually fixing the match case here.\n            ast.fix_missing_locations(case)\n        return desugared, deps\n\n    def _desugar_withitems(\n        self, withitems: list[ast.withitem]\n    ) -&gt; tuple[list[ast.withitem], list[ast.stmt]]:\n        # withitem(expr context_expr, expr? optional_vars)\n        desugared = []\n        deps = []\n        for withitem in withitems:\n            withitem.context_expr, context_expr_deps = self._desugar_expr(\n                withitem.context_expr\n            )\n            deps.extend(context_expr_deps)\n            if withitem.optional_vars is not None:\n                withitem.optional_vars, optional_vars_deps = self._desugar_expr(\n                    withitem.optional_vars\n                )\n                deps.extend(optional_vars_deps)\n            desugared.append(withitem)\n        return desugared, deps\n\n    def _desugar_comprehensions(\n        self, comprehensions: list[ast.comprehension], inner_statement: ast.stmt\n    ) -&gt; list[ast.stmt]:\n        # comprehension(expr target, expr iter, expr* ifs, int is_async)\n        stmt = inner_statement\n        while comprehensions:\n            last_for = comprehensions.pop()\n            while last_for.ifs:\n                test = last_for.ifs.pop()\n                stmt = ast.If(test=test, body=[stmt], orelse=[])\n            cls = ast.AsyncFor if last_for.is_async else ast.For\n            stmt = cls(\n                target=last_for.target, iter=last_for.iter, body=[stmt], orelse=[]\n            )\n\n        stmt, deps = self._desugar_stmt(stmt)\n        return deps + [stmt]\n\n    def _new_name(self) -&gt; str:\n        name = f\"_v{self.name_count}\"\n        self.name_count += 1\n        return name\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.desugar.desugar_function","title":"<code>desugar_function(fn_def)</code>","text":"<p>Desugar a function to simplify subsequent AST transformations.</p> <p>Parameters:</p> Name Type Description Default <code>fn_def</code> <code>FunctionDef</code> <p>A function definition.</p> required <p>Returns:</p> Name Type Description <code>FunctionDef</code> <code>FunctionDef</code> <p>The desugared function definition.</p> Source code in <code>dispatch/experimental/multicolor/desugar.py</code> <pre><code>def desugar_function(fn_def: ast.FunctionDef) -&gt; ast.FunctionDef:\n    \"\"\"Desugar a function to simplify subsequent AST transformations.\n\n    Args:\n        fn_def: A function definition.\n\n    Returns:\n        FunctionDef: The desugared function definition.\n    \"\"\"\n    fn_def.body = Desugar().desugar(fn_def.body)\n    ast.fix_missing_locations(fn_def)\n    return fn_def\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.generator","title":"<code>generator</code>","text":""},{"location":"#dispatch.experimental.multicolor.generator.YieldCounter","title":"<code>YieldCounter</code>","text":"<p>             Bases: <code>NodeVisitor</code></p> <p>AST visitor that walks an ast.FunctionDef to count yield and yield from statements.</p> <p>The resulting count can be used to determine if the input function is a generator or not.</p> <p>Yields from nested function/class definitions are not counted.</p> Source code in <code>dispatch/experimental/multicolor/generator.py</code> <pre><code>class YieldCounter(ast.NodeVisitor):\n    \"\"\"AST visitor that walks an ast.FunctionDef to count yield and yield from\n    statements.\n\n    The resulting count can be used to determine if the input function is\n    a generator or not.\n\n    Yields from nested function/class definitions are not counted.\n    \"\"\"\n\n    def __init__(self):\n        self.count = 0\n        self.depth = 0\n\n    def visit_Yield(self, node: ast.Yield):\n        self.count += 1\n\n    def visit_YieldFrom(self, node: ast.YieldFrom):\n        self.count += 1\n\n    def visit_FunctionDef(self, node: ast.FunctionDef):\n        self._visit_nested(node)\n\n    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):\n        self._visit_nested(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef):\n        self._visit_nested(node)\n\n    def _visit_nested(self, node: ast.stmt):\n        self.depth += 1\n        if self.depth &gt; 1:\n            return  # do not recurse\n        self.generic_visit(node)\n        self.depth -= 1\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.generator.empty_generator","title":"<code>empty_generator()</code>","text":"<p>A generator that yields nothing.</p> <p>A <code>yield from</code> this generator can be inserted into a function definition in order to turn the function into a generator, without causing any visible side effects.</p> Source code in <code>dispatch/experimental/multicolor/generator.py</code> <pre><code>def empty_generator():\n    \"\"\"A generator that yields nothing.\n\n    A `yield from` this generator can be inserted into a function definition in\n    order to turn the function into a generator, without causing any visible\n    side effects.\n    \"\"\"\n    if False:\n        yield\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.generator.is_generator","title":"<code>is_generator(fn_def)</code>","text":"<p>Returns a boolean indicating whether a function is a generator function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_def</code> <code>FunctionDef</code> <p>A function definition.</p> required Source code in <code>dispatch/experimental/multicolor/generator.py</code> <pre><code>def is_generator(fn_def: ast.FunctionDef) -&gt; bool:\n    \"\"\"Returns a boolean indicating whether a function is a\n    generator function.\n\n    Args:\n        fn_def: A function definition.\n    \"\"\"\n    yield_counter = YieldCounter()\n    yield_counter.visit(fn_def)\n    return yield_counter.count &gt; 0\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.parse","title":"<code>parse</code>","text":""},{"location":"#dispatch.experimental.multicolor.parse.NoSourceError","title":"<code>NoSourceError</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Function source code is not available.</p> Source code in <code>dispatch/experimental/multicolor/parse.py</code> <pre><code>class NoSourceError(RuntimeError):\n    \"\"\"Function source code is not available.\"\"\"\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.parse.parse_function","title":"<code>parse_function(fn)</code>","text":"<p>Parse an AST from a function. The function source must be available.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to parse.</p> required <p>Raises:</p> Type Description <code>NoSourceError</code> <p>If the function source cannot be retrieved.</p> Source code in <code>dispatch/experimental/multicolor/parse.py</code> <pre><code>def parse_function(fn: FunctionType) -&gt; tuple[ast.Module, ast.FunctionDef]:\n    \"\"\"Parse an AST from a function. The function source must be available.\n\n    Args:\n        fn: The function to parse.\n\n    Raises:\n        NoSourceError: If the function source cannot be retrieved.\n    \"\"\"\n    try:\n        src = inspect.getsource(fn)\n    except TypeError as e:\n        # The source is not always available. For example, the function\n        # may be defined in a C extension, or may be a builtin function.\n        raise NoSourceError from e\n    except OSError as e:\n        raise NoSourceError from e\n\n    try:\n        module = ast.parse(src)\n    except IndentationError:\n        module = ast.parse(textwrap.dedent(src))\n\n    fn_def = cast(ast.FunctionDef, module.body[0])\n    return module, fn_def\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.template","title":"<code>template</code>","text":""},{"location":"#dispatch.experimental.multicolor.template.NameTransformer","title":"<code>NameTransformer</code>","text":"<p>             Bases: <code>NodeTransformer</code></p> <p>Replace ast.Name nodes in an AST.</p> Source code in <code>dispatch/experimental/multicolor/template.py</code> <pre><code>class NameTransformer(ast.NodeTransformer):\n    \"\"\"Replace ast.Name nodes in an AST.\"\"\"\n\n    exprs: dict[str, ast.expr]\n    stmts: dict[str, ast.stmt]\n\n    def __init__(self, **replacements: ast.expr | ast.stmt):\n        self.exprs = {}\n        self.stmts = {}\n        for key, node in replacements.items():\n            if isinstance(node, ast.expr):\n                self.exprs[key] = node\n            elif isinstance(node, ast.stmt):\n                self.stmts[key] = node\n\n    def visit_Name(self, node: ast.Name) -&gt; ast.expr:\n        try:\n            return self.exprs[node.id]\n        except KeyError:\n            return node\n\n    def visit_Expr(self, node: ast.Expr) -&gt; ast.stmt:\n        if not isinstance(node.value, ast.Name):\n            return node\n        try:\n            return self.stmts[node.value.id]\n        except KeyError:\n            return node\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.template.rewrite_template","title":"<code>rewrite_template(template, **replacements)</code>","text":"<p>Create an AST by parsing a template string and then replacing embedded identifiers with the provided AST nodes.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>String containing source code (one or more statements).</p> required <code>**replacements</code> <code>expr | stmt</code> <p>Dictionary mapping identifiers to replacement nodes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[stmt]</code> <p>list[ast.stmt]: List of AST statements.</p> Source code in <code>dispatch/experimental/multicolor/template.py</code> <pre><code>def rewrite_template(\n    template: str, **replacements: ast.expr | ast.stmt\n) -&gt; list[ast.stmt]:\n    \"\"\"Create an AST by parsing a template string and then replacing\n    embedded identifiers with the provided AST nodes.\n\n    Args:\n        template: String containing source code (one or more statements).\n        **replacements: Dictionary mapping identifiers to replacement nodes.\n\n    Returns:\n        list[ast.stmt]: List of AST statements.\n    \"\"\"\n    root = ast.parse(textwrap.dedent(template))\n    root = NameTransformer(**replacements).visit(root)\n    return root.body\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.yields","title":"<code>yields</code>","text":""},{"location":"#dispatch.experimental.multicolor.yields.CustomYield","title":"<code>CustomYield</code>  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a function marked with @yields.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Any</code> <p>The type of yield that was specified in the @yields decorator.</p> <code>args</code> <code>list[Any]</code> <p>Positional arguments to the function call.</p> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to the function call.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>@dataclass\nclass CustomYield(YieldType):\n    \"\"\"A yield from a function marked with @yields.\n\n    Attributes:\n        type: The type of yield that was specified in the @yields decorator.\n        args: Positional arguments to the function call.\n        kwargs: Keyword arguments to the function call.\n    \"\"\"\n\n    type: Any\n    args: list[Any]\n    kwargs: dict[str, Any] | None = None\n\n    def kwarg(self, name, pos) -&gt; Any:\n        if self.kwargs is None:\n            return self.args[pos]\n        try:\n            return self.kwargs[name]\n        except KeyError:\n            return self.args[pos]\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.yields.GeneratorYield","title":"<code>GeneratorYield</code>  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a generator.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The value that was yielded from the generator.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>@dataclass\nclass GeneratorYield(YieldType):\n    \"\"\"A yield from a generator.\n\n    Attributes:\n        value: The value that was yielded from the generator.\n    \"\"\"\n\n    value: Any = None\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.yields.YieldType","title":"<code>YieldType</code>","text":"<p>Base class for yield types.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>class YieldType:\n    \"\"\"Base class for yield types.\"\"\"\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.yields.no_yields","title":"<code>no_yields(fn)</code>","text":"<p>Decorator that hints that a function (and anything called recursively) does not yield.</p> Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>def no_yields(fn):\n    \"\"\"Decorator that hints that a function (and anything called\n    recursively) does not yield.\"\"\"\n    fn._multicolor_no_yields = True  # type: ignore[attr-defined]\n    return fn\n</code></pre>"},{"location":"#dispatch.experimental.multicolor.yields.yields","title":"<code>yields(type)</code>","text":"<p>Returns a decorator that marks functions as a type of yield.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Any</code> <p>Opaque type for this yield.</p> required Source code in <code>dispatch/experimental/multicolor/yields.py</code> <pre><code>def yields(type: Any):\n    \"\"\"Returns a decorator that marks functions as a type of yield.\n\n    Args:\n        type: Opaque type for this yield.\n    \"\"\"\n\n    def decorator(fn: FunctionType) -&gt; FunctionType:\n        fn._multicolor_yield_type = type  # type: ignore[attr-defined]\n        return fn\n\n    return decorator\n</code></pre>"},{"location":"#dispatch.fastapi","title":"<code>fastapi</code>","text":"<p>Integration of Dispatch programmable endpoints for FastAPI.</p> <p>Example:</p> <pre><code>import fastapi\nfrom dispatch.fastapi import Dispatch\n\napp = fastapi.FastAPI()\ndispatch = Dispatch(app, api_key=\"test-key\")\n\n@dispatch.function()\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\ndef read_root():\n    dispatch.call(my_function)\n</code></pre>"},{"location":"#dispatch.fastapi.Dispatch","title":"<code>Dispatch</code>","text":"<p>             Bases: <code>Registry</code></p> <p>A Dispatch programmable endpoint, powered by FastAPI.</p> Source code in <code>dispatch/fastapi.py</code> <pre><code>class Dispatch(Registry):\n    \"\"\"A Dispatch programmable endpoint, powered by FastAPI.\"\"\"\n\n    def __init__(\n        self,\n        app: fastapi.FastAPI,\n        endpoint: str | None = None,\n        verification_key: Ed25519PublicKey | None = None,\n        api_key: str | None = None,\n        api_url: str | None = None,\n    ):\n        \"\"\"Initialize a Dispatch endpoint, and integrate it into a FastAPI app.\n\n        It mounts a sub-app that implements the Dispatch gRPC interface.\n\n        Args:\n            app: The FastAPI app to configure.\n\n            endpoint: Full URL of the application the Dispatch programmable\n              endpoint will be running on. Uses the value of the\n              DISPATCH_ENDPOINT_URL environment variable by default.\n\n            verification_key: Key to use when verifying signed requests. Uses\n              the value of the DISPATCH_VERIFICATION_KEY environment variable\n              by default. The environment variable is expected to carry an\n              Ed25519 public key in base64 or PEM format.\n\n            api_key: Dispatch API key to use for authentication. Uses the value of\n              the DISPATCH_API_KEY environment variable by default.\n\n            api_url: The URL of the Dispatch API to use. Uses the value of the\n              DISPATCH_API_URL environment variable if set, otherwise\n              defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n        Raises:\n            ValueError: If any of the required arguments are missing.\n        \"\"\"\n        if not app:\n            raise ValueError(\"app is required\")\n\n        if not endpoint:\n            endpoint = os.getenv(\"DISPATCH_ENDPOINT_URL\")\n        if not endpoint:\n            raise ValueError(\"endpoint is required\")\n\n        if not verification_key:\n            try:\n                verification_key_raw = os.environ[\"DISPATCH_VERIFICATION_KEY\"]\n            except KeyError:\n                pass\n            else:\n                # Be forgiving when accepting keys in PEM format.\n                verification_key_raw = verification_key_raw.replace(\"\\\\n\", \"\\n\")\n                try:\n                    verification_key = public_key_from_pem(verification_key_raw)\n                except ValueError:\n                    verification_key = public_key_from_bytes(\n                        base64.b64decode(verification_key_raw)\n                    )\n\n        logger.info(\"configuring Dispatch endpoint %s\", endpoint)\n\n        parsed_url = _urlparse.urlparse(endpoint)\n        if not parsed_url.netloc or not parsed_url.scheme:\n            raise ValueError(\"endpoint must be a full URL with protocol and domain\")\n\n        if verification_key:\n            base64_key = base64.b64encode(verification_key.public_bytes_raw()).decode()\n            logger.info(\"verifying request signatures using key %s\", base64_key)\n        else:\n            logger.warning(\"request verification is disabled\")\n\n        if not api_key:\n            api_key = os.environ.get(\"DISPATCH_API_KEY\")\n        if not api_url:\n            api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n\n        client = (\n            Client(api_key=api_key, api_url=api_url) if api_key and api_url else None\n        )\n\n        super().__init__(endpoint, client)\n\n        function_service = _new_app(self, verification_key)\n\n        app.mount(\"/dispatch.sdk.v1.FunctionService\", function_service)\n</code></pre>"},{"location":"#dispatch.fastapi.Dispatch.__init__","title":"<code>__init__(app, endpoint=None, verification_key=None, api_key=None, api_url=None)</code>","text":"<p>Initialize a Dispatch endpoint, and integrate it into a FastAPI app.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app to configure.</p> required <code>endpoint</code> <code>str | None</code> <p>Full URL of the application the Dispatch programmable endpoint will be running on. Uses the value of the DISPATCH_ENDPOINT_URL environment variable by default.</p> <code>None</code> <code>verification_key</code> <code>Ed25519PublicKey | None</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable by default. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format.</p> <code>None</code> <code>api_key</code> <code>str | None</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>str | None</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p> Source code in <code>dispatch/fastapi.py</code> <pre><code>def __init__(\n    self,\n    app: fastapi.FastAPI,\n    endpoint: str | None = None,\n    verification_key: Ed25519PublicKey | None = None,\n    api_key: str | None = None,\n    api_url: str | None = None,\n):\n    \"\"\"Initialize a Dispatch endpoint, and integrate it into a FastAPI app.\n\n    It mounts a sub-app that implements the Dispatch gRPC interface.\n\n    Args:\n        app: The FastAPI app to configure.\n\n        endpoint: Full URL of the application the Dispatch programmable\n          endpoint will be running on. Uses the value of the\n          DISPATCH_ENDPOINT_URL environment variable by default.\n\n        verification_key: Key to use when verifying signed requests. Uses\n          the value of the DISPATCH_VERIFICATION_KEY environment variable\n          by default. The environment variable is expected to carry an\n          Ed25519 public key in base64 or PEM format.\n\n        api_key: Dispatch API key to use for authentication. Uses the value of\n          the DISPATCH_API_KEY environment variable by default.\n\n        api_url: The URL of the Dispatch API to use. Uses the value of the\n          DISPATCH_API_URL environment variable if set, otherwise\n          defaults to the public Dispatch API (DEFAULT_DISPATCH_API_URL).\n\n    Raises:\n        ValueError: If any of the required arguments are missing.\n    \"\"\"\n    if not app:\n        raise ValueError(\"app is required\")\n\n    if not endpoint:\n        endpoint = os.getenv(\"DISPATCH_ENDPOINT_URL\")\n    if not endpoint:\n        raise ValueError(\"endpoint is required\")\n\n    if not verification_key:\n        try:\n            verification_key_raw = os.environ[\"DISPATCH_VERIFICATION_KEY\"]\n        except KeyError:\n            pass\n        else:\n            # Be forgiving when accepting keys in PEM format.\n            verification_key_raw = verification_key_raw.replace(\"\\\\n\", \"\\n\")\n            try:\n                verification_key = public_key_from_pem(verification_key_raw)\n            except ValueError:\n                verification_key = public_key_from_bytes(\n                    base64.b64decode(verification_key_raw)\n                )\n\n    logger.info(\"configuring Dispatch endpoint %s\", endpoint)\n\n    parsed_url = _urlparse.urlparse(endpoint)\n    if not parsed_url.netloc or not parsed_url.scheme:\n        raise ValueError(\"endpoint must be a full URL with protocol and domain\")\n\n    if verification_key:\n        base64_key = base64.b64encode(verification_key.public_bytes_raw()).decode()\n        logger.info(\"verifying request signatures using key %s\", base64_key)\n    else:\n        logger.warning(\"request verification is disabled\")\n\n    if not api_key:\n        api_key = os.environ.get(\"DISPATCH_API_KEY\")\n    if not api_url:\n        api_url = os.environ.get(\"DISPATCH_API_URL\", DEFAULT_API_URL)\n\n    client = (\n        Client(api_key=api_key, api_url=api_url) if api_key and api_url else None\n    )\n\n    super().__init__(endpoint, client)\n\n    function_service = _new_app(self, verification_key)\n\n    app.mount(\"/dispatch.sdk.v1.FunctionService\", function_service)\n</code></pre>"},{"location":"#dispatch.function","title":"<code>function</code>","text":""},{"location":"#dispatch.function.PrimitiveFunctionType","title":"<code>PrimitiveFunctionType: TypeAlias = Callable[[Input], Output]</code>  <code>module-attribute</code>","text":"<p>A primitive function is a function that accepts a dispatch.function.Input and unconditionally returns a dispatch.function.Output. It must not raise exceptions.</p>"},{"location":"#dispatch.function.Function","title":"<code>Function</code>","text":"<p>Callable wrapper around a function meant to be used throughout the Dispatch Python SDK.</p> Source code in <code>dispatch/function.py</code> <pre><code>class Function:\n    \"\"\"Callable wrapper around a function meant to be used throughout the\n    Dispatch Python SDK.\n    \"\"\"\n\n    def __init__(\n        self,\n        endpoint: str,\n        client: Client | None,\n        name: str,\n        func: Callable[[Input], Output],\n    ):\n        self._endpoint = endpoint\n        self._client = client\n        self._name = name\n        self._func = func\n\n    def __call__(self, *args, **kwargs):\n        return self._func(*args, **kwargs)\n\n    @property\n    def endpoint(self) -&gt; str:\n        return self._endpoint\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    def dispatch(self, *args, **kwargs) -&gt; DispatchID:\n        \"\"\"Dispatch a call to the function.\n\n        The Registry this function was registered with must be initialized\n        with a Client / api_key for this call facility to be available.\n\n        Args:\n            *args: Positional arguments for the function.\n            **kwargs: Keyword arguments for the function.\n\n        Returns:\n            DispatchID: ID of the dispatched call.\n\n        Raises:\n            RuntimeError: if a Dispatch client has not been configured.\n        \"\"\"\n        return self.primitive_dispatch(_Arguments(list(args), kwargs))\n\n    def primitive_dispatch(self, input: Any = None) -&gt; DispatchID:\n        \"\"\"Dispatch a primitive call.\n\n        The Registry this function was registered with must be initialized\n        with a Client / api_key for this call facility to be available.\n\n        Args:\n            input: Input to the function.\n\n        Returns:\n            DispatchID: ID of the dispatched call.\n\n        Raises:\n            RuntimeError: if a Dispatch client has not been configured.\n        \"\"\"\n        if self._client is None:\n            raise RuntimeError(\n                \"Dispatch Client has not been configured (api_key not provided)\"\n            )\n\n        [dispatch_id] = self._client.dispatch([self.primitive_call_with(input)])\n        return dispatch_id\n\n    @no_yields\n    def call_with(self, *args, correlation_id: int | None = None, **kwargs) -&gt; Call:\n        \"\"\"Create a Call for this function with the provided input. Useful to\n        generate calls when polling.\n\n        Args:\n            *args: Positional arguments for the function.\n            correlation_id: optional arbitrary integer the caller can use to\n              match this call to a call result.\n            **kwargs: Keyword arguments for the function.\n\n        Returns:\n            Call: can be passed to Output.poll().\n        \"\"\"\n        return self.primitive_call_with(\n            _Arguments(list(args), kwargs), correlation_id=correlation_id\n        )\n\n    def primitive_call_with(\n        self, input: Any, correlation_id: int | None = None\n    ) -&gt; Call:\n        \"\"\"Create a Call for this function with the provided input. Useful to\n        generate calls when polling.\n\n        Args:\n            input: any pickle-able Python value that will be passed as input to\n              this function.\n            correlation_id: optional arbitrary integer the caller can use to\n              match this call to a call result.\n\n        Returns:\n            Call: can be passed to Output.poll().\n        \"\"\"\n        return Call(\n            correlation_id=correlation_id,\n            endpoint=self.endpoint,\n            function=self.name,\n            input=input,\n        )\n</code></pre>"},{"location":"#dispatch.function.Function.call_with","title":"<code>call_with(*args, correlation_id=None, **kwargs)</code>","text":"<p>Create a Call for this function with the provided input. Useful to generate calls when polling.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>correlation_id</code> <code>int | None</code> <p>optional arbitrary integer the caller can use to match this call to a call result.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Output.poll().</p> Source code in <code>dispatch/function.py</code> <pre><code>@no_yields\ndef call_with(self, *args, correlation_id: int | None = None, **kwargs) -&gt; Call:\n    \"\"\"Create a Call for this function with the provided input. Useful to\n    generate calls when polling.\n\n    Args:\n        *args: Positional arguments for the function.\n        correlation_id: optional arbitrary integer the caller can use to\n          match this call to a call result.\n        **kwargs: Keyword arguments for the function.\n\n    Returns:\n        Call: can be passed to Output.poll().\n    \"\"\"\n    return self.primitive_call_with(\n        _Arguments(list(args), kwargs), correlation_id=correlation_id\n    )\n</code></pre>"},{"location":"#dispatch.function.Function.dispatch","title":"<code>dispatch(*args, **kwargs)</code>","text":"<p>Dispatch a call to the function.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a Dispatch client has not been configured.</p> Source code in <code>dispatch/function.py</code> <pre><code>def dispatch(self, *args, **kwargs) -&gt; DispatchID:\n    \"\"\"Dispatch a call to the function.\n\n    The Registry this function was registered with must be initialized\n    with a Client / api_key for this call facility to be available.\n\n    Args:\n        *args: Positional arguments for the function.\n        **kwargs: Keyword arguments for the function.\n\n    Returns:\n        DispatchID: ID of the dispatched call.\n\n    Raises:\n        RuntimeError: if a Dispatch client has not been configured.\n    \"\"\"\n    return self.primitive_dispatch(_Arguments(list(args), kwargs))\n</code></pre>"},{"location":"#dispatch.function.Function.primitive_call_with","title":"<code>primitive_call_with(input, correlation_id=None)</code>","text":"<p>Create a Call for this function with the provided input. Useful to generate calls when polling.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Any</code> <p>any pickle-able Python value that will be passed as input to this function.</p> required <code>correlation_id</code> <code>int | None</code> <p>optional arbitrary integer the caller can use to match this call to a call result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Output.poll().</p> Source code in <code>dispatch/function.py</code> <pre><code>def primitive_call_with(\n    self, input: Any, correlation_id: int | None = None\n) -&gt; Call:\n    \"\"\"Create a Call for this function with the provided input. Useful to\n    generate calls when polling.\n\n    Args:\n        input: any pickle-able Python value that will be passed as input to\n          this function.\n        correlation_id: optional arbitrary integer the caller can use to\n          match this call to a call result.\n\n    Returns:\n        Call: can be passed to Output.poll().\n    \"\"\"\n    return Call(\n        correlation_id=correlation_id,\n        endpoint=self.endpoint,\n        function=self.name,\n        input=input,\n    )\n</code></pre>"},{"location":"#dispatch.function.Function.primitive_dispatch","title":"<code>primitive_dispatch(input=None)</code>","text":"<p>Dispatch a primitive call.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Any</code> <p>Input to the function.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a Dispatch client has not been configured.</p> Source code in <code>dispatch/function.py</code> <pre><code>def primitive_dispatch(self, input: Any = None) -&gt; DispatchID:\n    \"\"\"Dispatch a primitive call.\n\n    The Registry this function was registered with must be initialized\n    with a Client / api_key for this call facility to be available.\n\n    Args:\n        input: Input to the function.\n\n    Returns:\n        DispatchID: ID of the dispatched call.\n\n    Raises:\n        RuntimeError: if a Dispatch client has not been configured.\n    \"\"\"\n    if self._client is None:\n        raise RuntimeError(\n            \"Dispatch Client has not been configured (api_key not provided)\"\n        )\n\n    [dispatch_id] = self._client.dispatch([self.primitive_call_with(input)])\n    return dispatch_id\n</code></pre>"},{"location":"#dispatch.function.Registry","title":"<code>Registry</code>","text":"<p>Registry of local functions.</p> Source code in <code>dispatch/function.py</code> <pre><code>class Registry:\n    \"\"\"Registry of local functions.\"\"\"\n\n    def __init__(self, endpoint: str, client: Client | None):\n        \"\"\"Initialize a local function registry.\n\n        Args:\n            endpoint: URL of the endpoint that the function is accessible from.\n            client: Optional client for the Dispatch API. If provided, calls\n              to local functions can be dispatched directly.\n        \"\"\"\n        self._functions: Dict[str, Function] = {}\n        self._endpoint = endpoint\n        self._client = client\n\n    def function(self) -&gt; Callable[[FunctionType], Function]:\n        \"\"\"Returns a decorator that registers functions.\"\"\"\n\n        # Note: the indirection here means that we can add parameters\n        # to the decorator later without breaking existing apps.\n        return self._register_function\n\n    def coroutine(self) -&gt; Callable[[FunctionType], Function | FunctionType]:\n        \"\"\"Returns a decorator that registers coroutine functions.\"\"\"\n\n        # Note: the indirection here means that we can add parameters\n        # to the decorator later without breaking existing apps.\n        return self._register_coroutine\n\n    def primitive_function(self) -&gt; Callable[[PrimitiveFunctionType], Function]:\n        \"\"\"Returns a decorator that registers primitive functions.\"\"\"\n\n        # Note: the indirection here means that we can add parameters\n        # to the decorator later without breaking existing apps.\n        return self._register_primitive_function\n\n    def _register_function(self, func: FunctionType) -&gt; Function:\n        \"\"\"Register a function with the Dispatch programmable endpoints.\n\n        Args:\n            func: The function to register.\n\n        Returns:\n            Function: A registered Dispatch Function.\n\n        Raises:\n            ValueError: If the function is already registered.\n        \"\"\"\n\n        @functools.wraps(func)\n        def primitive_func(input: Input) -&gt; Output:\n            try:\n                try:\n                    args, kwargs = input.input_arguments()\n                except ValueError:\n                    raise ValueError(\"incorrect input for function\")\n                raw_output = func(*args, **kwargs)\n            except Exception as e:\n                return Output.error(Error.from_exception(e))\n            else:\n                return Output.value(raw_output)\n\n        return self._register_primitive_function(primitive_func)\n\n    def _register_coroutine(self, func: FunctionType) -&gt; Function | FunctionType:\n        \"\"\"(EXPERIMENTAL) Register a coroutine function with the Dispatch\n        programmable endpoints.\n\n        The function is compiled into a durable coroutine.\n\n        The coroutine can use directives such as poll() partway through\n        execution. The coroutine will be suspended at these yield points,\n        and will resume execution from the same point when results are\n        available. The state of the coroutine is stored durably across\n        yield points.\n\n        Args:\n            func: The coroutine to register.\n\n        Returns:\n            Function: A registered Dispatch Function.\n\n        Raises:\n            ValueError: If the function is already registered.\n        \"\"\"\n\n        # FIXME: this is a funny issue that occurs where the compiled function\n        #  below has the same decorator and is thus registered again\n        for frame_info in inspect.stack():\n            if frame_info.function == compile_function.__name__:\n                return func\n\n        compiled_func = compile_function(func, decorator=durable, cache_key=\"dispatch\")\n\n        @functools.wraps(func)\n        def primitive_coro_func(input: Input) -&gt; Output:\n            try:\n                # (Re)hydrate the coroutine.\n                if input.is_first_call:\n                    logger.debug(\"starting coroutine\")\n                    try:\n                        args, kwargs = input.input_arguments()\n                    except ValueError:\n                        raise ValueError(\"incorrect input for function\")\n\n                    gen = compiled_func(*args, **kwargs)\n                    send = None\n                else:\n                    logger.debug(\n                        \"resuming coroutine with %d bytes of state and %d call result(s)\",\n                        len(input.coroutine_state),\n                        len(input.call_results),\n                    )\n                    try:\n                        coroutine_state = pickle.loads(input.coroutine_state)\n                        if not isinstance(coroutine_state, CoroutineState):\n                            raise ValueError(\"invalid coroutine state\")\n                        if coroutine_state.version != sys.version:\n                            raise ValueError(\n                                f\"coroutine state version mismatch: '{coroutine_state.version}' vs. current '{sys.version}'\"\n                            )\n                    except (pickle.PickleError, ValueError) as e:\n                        logger.warning(\"coroutine state is incompatible\", exc_info=True)\n                        return Output.error(\n                            Error.from_exception(e, status=Status.INCOMPATIBLE_STATE)\n                        )\n                    gen = coroutine_state.generator\n                    send = input.call_results\n\n                # Run the coroutine until its next yield or return.\n                try:\n                    directive = gen.send(send)\n                except StopIteration as e:\n                    logger.debug(\"coroutine returned\")\n                    return Output.value(e.value)  # Return value.\n\n                # Handle directives that it yields.\n                logger.debug(\"handling coroutine directive: %s\", directive)\n                match directive:\n                    case CustomYield(type=Directive.EXIT):\n                        result = directive.kwarg(\"result\", 0)\n                        tail_call = directive.kwarg(\"tail_call\", 1)\n                        status = status_for_output(result)\n                        return Output.exit(\n                            result=CallResult.from_value(result),\n                            tail_call=tail_call,\n                            status=status,\n                        )\n\n                    case CustomYield(type=Directive.POLL):\n                        try:\n                            coroutine_state = pickle.dumps(\n                                CoroutineState(generator=gen, version=sys.version)\n                            )\n                        except pickle.PickleError as e:\n                            logger.error(\n                                \"coroutine could not be serialized\", exc_info=True\n                            )\n                            return Output.error(\n                                Error.from_exception(e, status=Status.PERMANENT_ERROR)\n                            )\n                        calls = directive.kwarg(\"calls\", 0)\n                        return Output.poll(state=coroutine_state, calls=calls)\n\n                    case _:\n                        if isinstance(directive, GeneratorYield):\n                            directive = directive.value\n                        raise RuntimeError(\n                            f\"coroutine unexpectedly yielded '{directive}'\"\n                        )\n\n            except Exception as e:\n                logger.error(\"coroutine raised exception\", exc_info=True)\n                return Output.error(Error.from_exception(e))\n\n        return self._register_primitive_function(primitive_coro_func)\n\n    def _register_primitive_function(self, func: PrimitiveFunctionType) -&gt; Function:\n        \"\"\"Register a primitive function with the Dispatch programmable endpoints.\n\n        Args:\n            func: The function to register.\n\n        Returns:\n            Function: A registered Dispatch Function.\n\n        Raises:\n            ValueError: If the function is already registered.\n        \"\"\"\n        name = func.__qualname__\n        logger.info(\"registering function '%s'\", name)\n        if name in self._functions:\n            raise ValueError(f\"Function {name} already registered\")\n        wrapped_func = Function(self._endpoint, self._client, name, func)\n        self._functions[name] = wrapped_func\n        return wrapped_func\n</code></pre>"},{"location":"#dispatch.function.Registry.__init__","title":"<code>__init__(endpoint, client)</code>","text":"<p>Initialize a local function registry.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>URL of the endpoint that the function is accessible from.</p> required <code>client</code> <code>Client | None</code> <p>Optional client for the Dispatch API. If provided, calls to local functions can be dispatched directly.</p> required Source code in <code>dispatch/function.py</code> <pre><code>def __init__(self, endpoint: str, client: Client | None):\n    \"\"\"Initialize a local function registry.\n\n    Args:\n        endpoint: URL of the endpoint that the function is accessible from.\n        client: Optional client for the Dispatch API. If provided, calls\n          to local functions can be dispatched directly.\n    \"\"\"\n    self._functions: Dict[str, Function] = {}\n    self._endpoint = endpoint\n    self._client = client\n</code></pre>"},{"location":"#dispatch.function.Registry.coroutine","title":"<code>coroutine()</code>","text":"<p>Returns a decorator that registers coroutine functions.</p> Source code in <code>dispatch/function.py</code> <pre><code>def coroutine(self) -&gt; Callable[[FunctionType], Function | FunctionType]:\n    \"\"\"Returns a decorator that registers coroutine functions.\"\"\"\n\n    # Note: the indirection here means that we can add parameters\n    # to the decorator later without breaking existing apps.\n    return self._register_coroutine\n</code></pre>"},{"location":"#dispatch.function.Registry.function","title":"<code>function()</code>","text":"<p>Returns a decorator that registers functions.</p> Source code in <code>dispatch/function.py</code> <pre><code>def function(self) -&gt; Callable[[FunctionType], Function]:\n    \"\"\"Returns a decorator that registers functions.\"\"\"\n\n    # Note: the indirection here means that we can add parameters\n    # to the decorator later without breaking existing apps.\n    return self._register_function\n</code></pre>"},{"location":"#dispatch.function.Registry.primitive_function","title":"<code>primitive_function()</code>","text":"<p>Returns a decorator that registers primitive functions.</p> Source code in <code>dispatch/function.py</code> <pre><code>def primitive_function(self) -&gt; Callable[[PrimitiveFunctionType], Function]:\n    \"\"\"Returns a decorator that registers primitive functions.\"\"\"\n\n    # Note: the indirection here means that we can add parameters\n    # to the decorator later without breaking existing apps.\n    return self._register_primitive_function\n</code></pre>"},{"location":"#dispatch.id","title":"<code>id</code>","text":""},{"location":"#dispatch.id.DispatchID","title":"<code>DispatchID: TypeAlias = str</code>  <code>module-attribute</code>","text":"<p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"#dispatch.integrations","title":"<code>integrations</code>","text":""},{"location":"#dispatch.integrations.http","title":"<code>http</code>","text":""},{"location":"#dispatch.integrations.http.http_response_code_status","title":"<code>http_response_code_status(code)</code>","text":"<p>Returns a Status that's broadly equivalent to an HTTP response status code.</p> Source code in <code>dispatch/integrations/http.py</code> <pre><code>def http_response_code_status(code: int) -&gt; Status:\n    \"\"\"Returns a Status that's broadly equivalent to an HTTP response\n    status code.\"\"\"\n    match code:\n        case 429:  # Too Many Requests\n            return Status.THROTTLED\n        case 501:  # Not Implemented\n            return Status.PERMANENT_ERROR\n\n    category = code // 100\n    match category:\n        case 1:  # 1xx informational\n            return Status.PERMANENT_ERROR\n        case 2:  # 2xx success\n            return Status.OK\n        case 3:  # 3xx redirection\n            return Status.PERMANENT_ERROR\n        case 4:  # 4xx client error\n            return Status.PERMANENT_ERROR\n        case 5:  # 5xx server error\n            return Status.TEMPORARY_ERROR\n\n    return Status.UNSPECIFIED\n</code></pre>"},{"location":"#dispatch.integrations.httpx","title":"<code>httpx</code>","text":""},{"location":"#dispatch.integrations.requests","title":"<code>requests</code>","text":""},{"location":"#dispatch.proto","title":"<code>proto</code>","text":""},{"location":"#dispatch.proto.Call","title":"<code>Call</code>  <code>dataclass</code>","text":"<p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@dataclass\nclass Call:\n    \"\"\"Instruction to call a function.\n\n    Though this class can be built manually, it is recommended to use the\n    with_call method of a Function instead.\n    \"\"\"\n\n    function: str\n    input: Any\n    endpoint: str | None = None\n    correlation_id: int | None = None\n\n    def _as_proto(self) -&gt; call_pb.Call:\n        input_bytes = _pb_any_pickle(self.input)\n        return call_pb.Call(\n            correlation_id=self.correlation_id,\n            endpoint=self.endpoint,\n            function=self.function,\n            input=input_bytes,\n        )\n</code></pre>"},{"location":"#dispatch.proto.CallResult","title":"<code>CallResult</code>  <code>dataclass</code>","text":"<p>Result of a Call.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@dataclass\nclass CallResult:\n    \"\"\"Result of a Call.\"\"\"\n\n    correlation_id: int | None = None\n    output: Any | None = None\n    error: Error | None = None\n\n    def _as_proto(self) -&gt; call_pb.CallResult:\n        output_any = None\n        error_proto = None\n        if self.output is not None:\n            output_any = _pb_any_pickle(self.output)\n        if self.error is not None:\n            error_proto = self.error._as_proto()\n\n        return call_pb.CallResult(\n            correlation_id=self.correlation_id, output=output_any, error=error_proto\n        )\n\n    @classmethod\n    def _from_proto(cls, proto: call_pb.CallResult) -&gt; CallResult:\n        output = None\n        error = None\n        if proto.HasField(\"output\"):\n            output = _any_unpickle(proto.output)\n        if proto.HasField(\"error\"):\n            error = Error._from_proto(proto.error)\n\n        return CallResult(\n            correlation_id=proto.correlation_id, output=output, error=error\n        )\n\n    @classmethod\n    def from_value(cls, output: Any, correlation_id: int | None = None) -&gt; CallResult:\n        return CallResult(correlation_id=correlation_id, output=output)\n\n    @classmethod\n    def from_error(cls, error: Error, correlation_id: int | None = None) -&gt; CallResult:\n        return CallResult(correlation_id=correlation_id, error=error)\n</code></pre>"},{"location":"#dispatch.proto.Error","title":"<code>Error</code>","text":"<p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Error:\n    \"\"\"Error when running a function.\n\n    This is not a Python exception, but potentially part of a CallResult or\n    Output.\n    \"\"\"\n\n    def __init__(self, status: Status, type: str | None, message: str | None):\n        \"\"\"Create a new Error.\n\n        Args:\n            status: categorization of the error.\n            type: arbitrary string, used for humans. Optional.\n            message: arbitrary message. Optional.\n\n        Raises:\n            ValueError: Neither type or message was provided or status is\n              invalid.\n        \"\"\"\n        if type is None and message is None:\n            raise ValueError(\"At least one of type or message is required\")\n        if status is Status.OK:\n            raise ValueError(\"Status cannot be OK\")\n\n        self.type = type\n        self.message = message\n        self.status = status\n\n    @classmethod\n    def from_exception(cls, ex: Exception, status: Status | None = None) -&gt; Error:\n        \"\"\"Create an Error from a Python exception, using its class qualified\n        named as type.\n\n        The status tries to be inferred, but can be overriden. If it is not\n        provided or cannot be inferred, it defaults to TEMPORARY_ERROR.\n        \"\"\"\n\n        if status is None:\n            status = status_for_error(ex)\n\n        return Error(status, ex.__class__.__qualname__, str(ex))\n\n    @classmethod\n    def _from_proto(cls, proto: error_pb.Error) -&gt; Error:\n        return cls(Status.UNSPECIFIED, proto.type, proto.message)\n\n    def _as_proto(self) -&gt; error_pb.Error:\n        return error_pb.Error(type=self.type, message=self.message)\n</code></pre>"},{"location":"#dispatch.proto.Error.__init__","title":"<code>__init__(status, type, message)</code>","text":"<p>Create a new Error.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str | None</code> <p>arbitrary string, used for humans. Optional.</p> required <code>message</code> <code>str | None</code> <p>arbitrary message. Optional.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p> Source code in <code>dispatch/proto.py</code> <pre><code>def __init__(self, status: Status, type: str | None, message: str | None):\n    \"\"\"Create a new Error.\n\n    Args:\n        status: categorization of the error.\n        type: arbitrary string, used for humans. Optional.\n        message: arbitrary message. Optional.\n\n    Raises:\n        ValueError: Neither type or message was provided or status is\n          invalid.\n    \"\"\"\n    if type is None and message is None:\n        raise ValueError(\"At least one of type or message is required\")\n    if status is Status.OK:\n        raise ValueError(\"Status cannot be OK\")\n\n    self.type = type\n    self.message = message\n    self.status = status\n</code></pre>"},{"location":"#dispatch.proto.Error.from_exception","title":"<code>from_exception(ex, status=None)</code>  <code>classmethod</code>","text":"<p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overriden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef from_exception(cls, ex: Exception, status: Status | None = None) -&gt; Error:\n    \"\"\"Create an Error from a Python exception, using its class qualified\n    named as type.\n\n    The status tries to be inferred, but can be overriden. If it is not\n    provided or cannot be inferred, it defaults to TEMPORARY_ERROR.\n    \"\"\"\n\n    if status is None:\n        status = status_for_error(ex)\n\n    return Error(status, ex.__class__.__qualname__, str(ex))\n</code></pre>"},{"location":"#dispatch.proto.Input","title":"<code>Input</code>","text":"<p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Input:\n    \"\"\"The input to a primitive function.\n\n    Functions always take a single argument of type Input. When the function is\n    run for the first time, it receives the input. When the function is a coroutine\n    that's resuming after a yield point, it receives the results of the yield\n    directive. Use the is_first_call and is_resume properties to differentiate\n    between the two cases.\n\n    This class is intended to be used as read-only.\n    \"\"\"\n\n    def __init__(self, req: function_pb.RunRequest):\n        self._has_input = req.HasField(\"input\")\n        if self._has_input:\n            input_pb = google.protobuf.wrappers_pb2.BytesValue()\n            req.input.Unpack(input_pb)\n            input_bytes = input_pb.value\n            self._input = pickle.loads(input_bytes)\n        else:\n            state_bytes = req.poll_result.coroutine_state\n            if len(state_bytes) &gt; 0:\n                self._coroutine_state = pickle.loads(state_bytes)\n            else:\n                self._coroutine_state = None\n            self._call_results = [\n                CallResult._from_proto(r) for r in req.poll_result.results\n            ]\n\n    @property\n    def is_first_call(self) -&gt; bool:\n        return self._has_input\n\n    @property\n    def is_resume(self) -&gt; bool:\n        return not self.is_first_call\n\n    @property\n    def input(self) -&gt; Any:\n        self._assert_first_call()\n        return self._input\n\n    def input_arguments(self) -&gt; tuple[list[Any], dict[str, Any]]:\n        \"\"\"Returns positional and keyword arguments carried by the input.\"\"\"\n        self._assert_first_call()\n        if not isinstance(self._input, _Arguments):\n            raise RuntimeError(\"input does not hold arguments\")\n        return self._input.args, self._input.kwargs\n\n    @property\n    def coroutine_state(self) -&gt; Any:\n        self._assert_resume()\n        return self._coroutine_state\n\n    @property\n    def call_results(self) -&gt; list[CallResult]:\n        self._assert_resume()\n        return self._call_results\n\n    def _assert_first_call(self):\n        if self.is_resume:\n            raise ValueError(\"This input is for a resumed coroutine\")\n\n    def _assert_resume(self):\n        if self.is_first_call:\n            raise ValueError(\"This input is for a first function call\")\n</code></pre>"},{"location":"#dispatch.proto.Input.input_arguments","title":"<code>input_arguments()</code>","text":"<p>Returns positional and keyword arguments carried by the input.</p> Source code in <code>dispatch/proto.py</code> <pre><code>def input_arguments(self) -&gt; tuple[list[Any], dict[str, Any]]:\n    \"\"\"Returns positional and keyword arguments carried by the input.\"\"\"\n    self._assert_first_call()\n    if not isinstance(self._input, _Arguments):\n        raise RuntimeError(\"input does not hold arguments\")\n    return self._input.args, self._input.kwargs\n</code></pre>"},{"location":"#dispatch.proto.Output","title":"<code>Output</code>","text":"<p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p> Source code in <code>dispatch/proto.py</code> <pre><code>class Output:\n    \"\"\"The output of a primitive function.\n\n    This class is meant to be instantiated and returned by authors of functions\n    to indicate the follow up action they need to take. Use the various class\n    methods create an instance of this class. For example Output.value() or\n    Output.poll().\n    \"\"\"\n\n    def __init__(self, proto: function_pb.RunResponse):\n        self._message = proto\n\n    @classmethod\n    def value(cls, value: Any, status: Status | None = None) -&gt; Output:\n        \"\"\"Terminally exit the function with the provided return value.\"\"\"\n        if status is None:\n            status = status_for_output(value)\n        return cls.exit(result=CallResult.from_value(value), status=status)\n\n    @classmethod\n    def error(cls, error: Error) -&gt; Output:\n        \"\"\"Terminally exit the function with the provided error.\"\"\"\n        return cls.exit(result=CallResult.from_error(error), status=error.status)\n\n    @classmethod\n    def tail_call(cls, tail_call: Call) -&gt; Output:\n        \"\"\"Terminally exit the function, and instruct the orchestrator to\n        tail call the specified function.\"\"\"\n        return cls.exit(tail_call=tail_call)\n\n    @classmethod\n    def exit(\n        cls,\n        result: CallResult | None = None,\n        tail_call: Call | None = None,\n        status: Status = Status.OK,\n    ) -&gt; Output:\n        \"\"\"Terminally exit the function.\"\"\"\n        result_proto = result._as_proto() if result else None\n        tail_call_proto = tail_call._as_proto() if tail_call else None\n        return Output(\n            function_pb.RunResponse(\n                status=status._proto,\n                exit=exit_pb.Exit(result=result_proto, tail_call=tail_call_proto),\n            )\n        )\n\n    @classmethod\n    def poll(cls, state: Any, calls: None | list[Call] = None) -&gt; Output:\n        \"\"\"Suspend the function with a set of Calls, instructing the\n        orchestrator to resume the function with the provided state when\n        call results are ready.\"\"\"\n        state_bytes = pickle.dumps(state)\n        poll = poll_pb.Poll(\n            coroutine_state=state_bytes,\n            # FIXME: make this configurable\n            max_results=1,\n            max_wait=duration_pb2.Duration(seconds=5),\n        )\n\n        if calls is not None:\n            for c in calls:\n                poll.calls.append(c._as_proto())\n\n        return Output(\n            function_pb.RunResponse(\n                status=status_pb.STATUS_OK,\n                poll=poll,\n            )\n        )\n</code></pre>"},{"location":"#dispatch.proto.Output.error","title":"<code>error(error)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function with the provided error.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef error(cls, error: Error) -&gt; Output:\n    \"\"\"Terminally exit the function with the provided error.\"\"\"\n    return cls.exit(result=CallResult.from_error(error), status=error.status)\n</code></pre>"},{"location":"#dispatch.proto.Output.exit","title":"<code>exit(result=None, tail_call=None, status=Status.OK)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef exit(\n    cls,\n    result: CallResult | None = None,\n    tail_call: Call | None = None,\n    status: Status = Status.OK,\n) -&gt; Output:\n    \"\"\"Terminally exit the function.\"\"\"\n    result_proto = result._as_proto() if result else None\n    tail_call_proto = tail_call._as_proto() if tail_call else None\n    return Output(\n        function_pb.RunResponse(\n            status=status._proto,\n            exit=exit_pb.Exit(result=result_proto, tail_call=tail_call_proto),\n        )\n    )\n</code></pre>"},{"location":"#dispatch.proto.Output.poll","title":"<code>poll(state, calls=None)</code>  <code>classmethod</code>","text":"<p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef poll(cls, state: Any, calls: None | list[Call] = None) -&gt; Output:\n    \"\"\"Suspend the function with a set of Calls, instructing the\n    orchestrator to resume the function with the provided state when\n    call results are ready.\"\"\"\n    state_bytes = pickle.dumps(state)\n    poll = poll_pb.Poll(\n        coroutine_state=state_bytes,\n        # FIXME: make this configurable\n        max_results=1,\n        max_wait=duration_pb2.Duration(seconds=5),\n    )\n\n    if calls is not None:\n        for c in calls:\n            poll.calls.append(c._as_proto())\n\n    return Output(\n        function_pb.RunResponse(\n            status=status_pb.STATUS_OK,\n            poll=poll,\n        )\n    )\n</code></pre>"},{"location":"#dispatch.proto.Output.tail_call","title":"<code>tail_call(tail_call)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef tail_call(cls, tail_call: Call) -&gt; Output:\n    \"\"\"Terminally exit the function, and instruct the orchestrator to\n    tail call the specified function.\"\"\"\n    return cls.exit(tail_call=tail_call)\n</code></pre>"},{"location":"#dispatch.proto.Output.value","title":"<code>value(value, status=None)</code>  <code>classmethod</code>","text":"<p>Terminally exit the function with the provided return value.</p> Source code in <code>dispatch/proto.py</code> <pre><code>@classmethod\ndef value(cls, value: Any, status: Status | None = None) -&gt; Output:\n    \"\"\"Terminally exit the function with the provided return value.\"\"\"\n    if status is None:\n        status = status_for_output(value)\n    return cls.exit(result=CallResult.from_value(value), status=status)\n</code></pre>"},{"location":"#dispatch.sdk","title":"<code>sdk</code>","text":""},{"location":"#dispatch.sdk.v1","title":"<code>v1</code>","text":""},{"location":"#dispatch.sdk.v1.call_pb2","title":"<code>call_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.call_pb2_grpc","title":"<code>call_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.dispatch_pb2","title":"<code>dispatch_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc","title":"<code>dispatch_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc.DispatchService","title":"<code>DispatchService</code>","text":"<p>             Bases: <code>object</code></p> <p>DispatchService is a service allowing the trigger of programmable endpoints from a dispatch SDK.</p> Source code in <code>dispatch/sdk/v1/dispatch_pb2_grpc.py</code> <pre><code>class DispatchService(object):\n    \"\"\"DispatchService is a service allowing the trigger of programmable endpoints\n    from a dispatch SDK.\n    \"\"\"\n\n    @staticmethod\n    def Dispatch(\n        request,\n        target,\n        options=(),\n        channel_credentials=None,\n        call_credentials=None,\n        insecure=False,\n        compression=None,\n        wait_for_ready=None,\n        timeout=None,\n        metadata=None,\n    ):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            \"/dispatch.sdk.v1.DispatchService/Dispatch\",\n            dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchRequest.SerializeToString,\n            dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n        )\n</code></pre>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc.DispatchServiceServicer","title":"<code>DispatchServiceServicer</code>","text":"<p>             Bases: <code>object</code></p> <p>DispatchService is a service allowing the trigger of programmable endpoints from a dispatch SDK.</p> Source code in <code>dispatch/sdk/v1/dispatch_pb2_grpc.py</code> <pre><code>class DispatchServiceServicer(object):\n    \"\"\"DispatchService is a service allowing the trigger of programmable endpoints\n    from a dispatch SDK.\n    \"\"\"\n\n    def Dispatch(self, request, context):\n        \"\"\"Dispatch submits a list of asynchronous function calls to the service.\n\n        The method does not wait for executions to complete before returning,\n        it only ensures that the creation was persisted, and returns unique\n        identifiers to represent the executions.\n\n        The request contains a list of executions to be triggered; the method is\n        atomic, either all executions are recorded, or none and an error is\n        returned to explain the reason for the failure.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details(\"Method not implemented!\")\n        raise NotImplementedError(\"Method not implemented!\")\n</code></pre>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc.DispatchServiceServicer.Dispatch","title":"<code>Dispatch(request, context)</code>","text":"<p>Dispatch submits a list of asynchronous function calls to the service.</p> <p>The method does not wait for executions to complete before returning, it only ensures that the creation was persisted, and returns unique identifiers to represent the executions.</p> <p>The request contains a list of executions to be triggered; the method is atomic, either all executions are recorded, or none and an error is returned to explain the reason for the failure.</p> Source code in <code>dispatch/sdk/v1/dispatch_pb2_grpc.py</code> <pre><code>def Dispatch(self, request, context):\n    \"\"\"Dispatch submits a list of asynchronous function calls to the service.\n\n    The method does not wait for executions to complete before returning,\n    it only ensures that the creation was persisted, and returns unique\n    identifiers to represent the executions.\n\n    The request contains a list of executions to be triggered; the method is\n    atomic, either all executions are recorded, or none and an error is\n    returned to explain the reason for the failure.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details(\"Method not implemented!\")\n    raise NotImplementedError(\"Method not implemented!\")\n</code></pre>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc.DispatchServiceStub","title":"<code>DispatchServiceStub</code>","text":"<p>             Bases: <code>object</code></p> <p>DispatchService is a service allowing the trigger of programmable endpoints from a dispatch SDK.</p> Source code in <code>dispatch/sdk/v1/dispatch_pb2_grpc.py</code> <pre><code>class DispatchServiceStub(object):\n    \"\"\"DispatchService is a service allowing the trigger of programmable endpoints\n    from a dispatch SDK.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.Dispatch = channel.unary_unary(\n            \"/dispatch.sdk.v1.DispatchService/Dispatch\",\n            request_serializer=dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchRequest.SerializeToString,\n            response_deserializer=dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchResponse.FromString,\n        )\n</code></pre>"},{"location":"#dispatch.sdk.v1.dispatch_pb2_grpc.DispatchServiceStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>dispatch/sdk/v1/dispatch_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.Dispatch = channel.unary_unary(\n        \"/dispatch.sdk.v1.DispatchService/Dispatch\",\n        request_serializer=dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchRequest.SerializeToString,\n        response_deserializer=dispatch_dot_sdk_dot_v1_dot_dispatch__pb2.DispatchResponse.FromString,\n    )\n</code></pre>"},{"location":"#dispatch.sdk.v1.error_pb2","title":"<code>error_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.error_pb2_grpc","title":"<code>error_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.exit_pb2","title":"<code>exit_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.exit_pb2_grpc","title":"<code>exit_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.function_pb2","title":"<code>function_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc","title":"<code>function_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc.FunctionService","title":"<code>FunctionService</code>","text":"<p>             Bases: <code>object</code></p> <p>The FunctionService service is used to interface with programmable endpoints exposing remote functions.</p> Source code in <code>dispatch/sdk/v1/function_pb2_grpc.py</code> <pre><code>class FunctionService(object):\n    \"\"\"The FunctionService service is used to interface with programmable endpoints\n    exposing remote functions.\n    \"\"\"\n\n    @staticmethod\n    def Run(\n        request,\n        target,\n        options=(),\n        channel_credentials=None,\n        call_credentials=None,\n        insecure=False,\n        compression=None,\n        wait_for_ready=None,\n        timeout=None,\n        metadata=None,\n    ):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            \"/dispatch.sdk.v1.FunctionService/Run\",\n            dispatch_dot_sdk_dot_v1_dot_function__pb2.RunRequest.SerializeToString,\n            dispatch_dot_sdk_dot_v1_dot_function__pb2.RunResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n        )\n</code></pre>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc.FunctionServiceServicer","title":"<code>FunctionServiceServicer</code>","text":"<p>             Bases: <code>object</code></p> <p>The FunctionService service is used to interface with programmable endpoints exposing remote functions.</p> Source code in <code>dispatch/sdk/v1/function_pb2_grpc.py</code> <pre><code>class FunctionServiceServicer(object):\n    \"\"\"The FunctionService service is used to interface with programmable endpoints\n    exposing remote functions.\n    \"\"\"\n\n    def Run(self, request, context):\n        \"\"\"Run runs the function identified by the request, and returns a response\n        that either contains a result when the function completed, or a poll\n        directive and the associated coroutine state if the function was suspended.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details(\"Method not implemented!\")\n        raise NotImplementedError(\"Method not implemented!\")\n</code></pre>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc.FunctionServiceServicer.Run","title":"<code>Run(request, context)</code>","text":"<p>Run runs the function identified by the request, and returns a response that either contains a result when the function completed, or a poll directive and the associated coroutine state if the function was suspended.</p> Source code in <code>dispatch/sdk/v1/function_pb2_grpc.py</code> <pre><code>def Run(self, request, context):\n    \"\"\"Run runs the function identified by the request, and returns a response\n    that either contains a result when the function completed, or a poll\n    directive and the associated coroutine state if the function was suspended.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details(\"Method not implemented!\")\n    raise NotImplementedError(\"Method not implemented!\")\n</code></pre>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc.FunctionServiceStub","title":"<code>FunctionServiceStub</code>","text":"<p>             Bases: <code>object</code></p> <p>The FunctionService service is used to interface with programmable endpoints exposing remote functions.</p> Source code in <code>dispatch/sdk/v1/function_pb2_grpc.py</code> <pre><code>class FunctionServiceStub(object):\n    \"\"\"The FunctionService service is used to interface with programmable endpoints\n    exposing remote functions.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.Run = channel.unary_unary(\n            \"/dispatch.sdk.v1.FunctionService/Run\",\n            request_serializer=dispatch_dot_sdk_dot_v1_dot_function__pb2.RunRequest.SerializeToString,\n            response_deserializer=dispatch_dot_sdk_dot_v1_dot_function__pb2.RunResponse.FromString,\n        )\n</code></pre>"},{"location":"#dispatch.sdk.v1.function_pb2_grpc.FunctionServiceStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>dispatch/sdk/v1/function_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.Run = channel.unary_unary(\n        \"/dispatch.sdk.v1.FunctionService/Run\",\n        request_serializer=dispatch_dot_sdk_dot_v1_dot_function__pb2.RunRequest.SerializeToString,\n        response_deserializer=dispatch_dot_sdk_dot_v1_dot_function__pb2.RunResponse.FromString,\n    )\n</code></pre>"},{"location":"#dispatch.sdk.v1.poll_pb2","title":"<code>poll_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.poll_pb2_grpc","title":"<code>poll_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.sdk.v1.status_pb2","title":"<code>status_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"#dispatch.sdk.v1.status_pb2_grpc","title":"<code>status_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"#dispatch.signature","title":"<code>signature</code>","text":""},{"location":"#dispatch.signature.sign_request","title":"<code>sign_request(request, key, created)</code>","text":"<p>Sign a request using HTTP Message Signatures.</p> <p>The function adds three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The signature covers the request method, the URL host and path, the Content-Type header, and the request body. At this time, an ED25519 signature is generated with a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to sign.</p> required <code>key</code> <code>Ed25519PrivateKey</code> <p>The Ed25519 private key to use to generate the signature.</p> required <code>created</code> <code>datetime</code> <p>The times at which the signature is created.</p> required Source code in <code>dispatch/signature/__init__.py</code> <pre><code>def sign_request(request: Request, key: Ed25519PrivateKey, created: datetime):\n    \"\"\"Sign a request using HTTP Message Signatures.\n\n    The function adds three additional headers: Content-Digest,\n    Signature-Input, and Signature. See the following spec for more details:\n    https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures\n\n    The signature covers the request method, the URL host and path, the\n    Content-Type header, and the request body. At this time, an ED25519\n    signature is generated with a hard-coded key ID of \"default\".\n\n    Args:\n        request: The request to sign.\n        key: The Ed25519 private key to use to generate the signature.\n        created: The times at which the signature is created.\n    \"\"\"\n    logger.debug(\"signing request with %d byte body\", len(request.body))\n    request.headers[\"Content-Digest\"] = generate_content_digest(request.body)\n\n    signer = HTTPMessageSigner(\n        signature_algorithm=ALGORITHM,\n        key_resolver=KeyResolver(key_id=DEFAULT_KEY_ID, private_key=key),\n    )\n    signer.sign(\n        request,\n        key_id=DEFAULT_KEY_ID,\n        covered_component_ids=cast(Sequence[str], COVERED_COMPONENT_IDS),\n        created=created,\n        label=\"dispatch\",\n        include_alg=True,\n    )\n    logger.debug(\"signed request successfully\")\n</code></pre>"},{"location":"#dispatch.signature.verify_request","title":"<code>verify_request(request, key, max_age)</code>","text":"<p>Verify a request containing an HTTP Message Signature.</p> <p>The function checks three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The function checks signatures that cover at least the request method, the URL host and path, the Content-Type header, and the request body (via the Content-Digest header). At this time, signatures must use a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to verify.</p> required <code>key</code> <code>Ed25519PublicKey</code> <p>The Ed25519 public key to use to verify the signature.</p> required <code>max_age</code> <code>timedelta</code> <p>The maximum age of the signature.</p> required Source code in <code>dispatch/signature/__init__.py</code> <pre><code>def verify_request(request: Request, key: Ed25519PublicKey, max_age: timedelta):\n    \"\"\"Verify a request containing an HTTP Message Signature.\n\n    The function checks three additional headers: Content-Digest,\n    Signature-Input, and Signature. See the following spec for more details:\n    https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures\n\n    The function checks signatures that cover at least the request method, the\n    URL host and path, the Content-Type header, and the request body (via the\n    Content-Digest header). At this time, signatures must use a hard-coded key\n    ID of \"default\".\n\n    Args:\n        request: The request to verify.\n        key: The Ed25519 public key to use to verify the signature.\n        max_age: The maximum age of the signature.\n    \"\"\"\n    logger.debug(\"verifying request signature\")\n\n    # Verify embedded signatures.\n    key_resolver = KeyResolver(key_id=DEFAULT_KEY_ID, public_key=key)\n    verifier = HTTPMessageVerifier(\n        signature_algorithm=ALGORITHM, key_resolver=key_resolver\n    )\n    results = verifier.verify(request, max_age=max_age)\n\n    # Check that at least one signature covers the required components.\n    for result in results:\n        covered_components = extract_covered_components(result)\n        if covered_components.issuperset(COVERED_COMPONENT_IDS):\n            break\n    else:\n        raise ValueError(\n            f\"no signatures found that covered all required components ({COVERED_COMPONENT_IDS})\"\n        )\n\n    # Check that the Content-Digest header matches the body.\n    verify_content_digest(request.headers[\"Content-Digest\"], request.body)\n</code></pre>"},{"location":"#dispatch.signature.digest","title":"<code>digest</code>","text":""},{"location":"#dispatch.signature.digest.generate_content_digest","title":"<code>generate_content_digest(body)</code>","text":"<p>Returns a SHA-512 Content-Digest header, according to https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13</p> Source code in <code>dispatch/signature/digest.py</code> <pre><code>def generate_content_digest(body: str | bytes) -&gt; str:\n    \"\"\"Returns a SHA-512 Content-Digest header, according to\n    https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13\n    \"\"\"\n    if isinstance(body, str):\n        body = body.encode()\n\n    digest = hashlib.sha512(body).digest()\n    return str(http_sfv.Dictionary({\"sha-512\": digest}))\n</code></pre>"},{"location":"#dispatch.signature.digest.verify_content_digest","title":"<code>verify_content_digest(digest_header, body)</code>","text":"<p>Verify a SHA-256 or SHA-512 Content-Digest header matches a request body.</p> Source code in <code>dispatch/signature/digest.py</code> <pre><code>def verify_content_digest(digest_header: str | bytes, body: str | bytes):\n    \"\"\"Verify a SHA-256 or SHA-512 Content-Digest header matches a\n    request body.\"\"\"\n    if isinstance(body, str):\n        body = body.encode()\n    if isinstance(digest_header, str):\n        digest_header = digest_header.encode()\n\n    parsed_header = http_sfv.Dictionary()\n    parsed_header.parse(digest_header)\n\n    # See https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13#establish-hash-algorithm-registry\n    if \"sha-512\" in parsed_header:\n        digest = parsed_header[\"sha-512\"].value\n        expect_digest = hashlib.sha512(body).digest()\n    elif \"sha-256\" in parsed_header:\n        digest = parsed_header[\"sha-256\"].value\n        expect_digest = hashlib.sha256(body).digest()\n    else:\n        raise ValueError(\"missing content digest\")\n\n    if not hmac.compare_digest(digest, expect_digest):\n        raise ValueError(\"unexpected content digest\")\n</code></pre>"},{"location":"#dispatch.signature.key","title":"<code>key</code>","text":""},{"location":"#dispatch.signature.key.KeyResolver","title":"<code>KeyResolver</code>  <code>dataclass</code>","text":"<p>             Bases: <code>HTTPSignatureKeyResolver</code></p> <p>KeyResolver provides public and private keys.</p> <p>At this time, multiple keys and/or key types are not supported. Keys must be Ed25519 keys and have an ID of DEFAULT_KEY_ID.</p> Source code in <code>dispatch/signature/key.py</code> <pre><code>@dataclass\nclass KeyResolver(HTTPSignatureKeyResolver):\n    \"\"\"KeyResolver provides public and private keys.\n\n    At this time, multiple keys and/or key types are not supported.\n    Keys must be Ed25519 keys and have an ID of DEFAULT_KEY_ID.\n    \"\"\"\n\n    key_id: str\n    public_key: Ed25519PublicKey | None = None\n    private_key: Ed25519PrivateKey | None = None\n\n    def resolve_public_key(self, key_id: str):\n        if key_id != self.key_id or self.public_key is None:\n            raise ValueError(f\"public key '{key_id}' not available\")\n\n        return self.public_key\n\n    def resolve_private_key(self, key_id: str):\n        if key_id != self.key_id or self.private_key is None:\n            raise ValueError(f\"private key '{key_id}' not available\")\n\n        return self.private_key\n</code></pre>"},{"location":"#dispatch.signature.key.private_key_from_bytes","title":"<code>private_key_from_bytes(key)</code>","text":"<p>Returns an Ed25519 private key from 32 raw bytes.</p> Source code in <code>dispatch/signature/key.py</code> <pre><code>def private_key_from_bytes(key: bytes) -&gt; Ed25519PrivateKey:\n    \"\"\"Returns an Ed25519 private key from 32 raw bytes.\"\"\"\n    return Ed25519PrivateKey.from_private_bytes(key)\n</code></pre>"},{"location":"#dispatch.signature.key.private_key_from_pem","title":"<code>private_key_from_pem(pem, password=None)</code>","text":"<p>Returns an Ed25519 private key given a PEM representation and optional password.</p> Source code in <code>dispatch/signature/key.py</code> <pre><code>def private_key_from_pem(\n    pem: str | bytes, password: bytes | None = None\n) -&gt; Ed25519PrivateKey:\n    \"\"\"Returns an Ed25519 private key given a PEM representation\n    and optional password.\"\"\"\n    if isinstance(pem, str):\n        pem = pem.encode()\n    if isinstance(password, str):\n        password = password.encode()\n\n    key = load_pem_private_key(pem, password=password)\n    if not isinstance(key, Ed25519PrivateKey):\n        raise ValueError(f\"unexpected private key type: {type(key)}\")\n    return key\n</code></pre>"},{"location":"#dispatch.signature.key.public_key_from_bytes","title":"<code>public_key_from_bytes(key)</code>","text":"<p>Returns an Ed25519 public key from 32 raw bytes.</p> Source code in <code>dispatch/signature/key.py</code> <pre><code>def public_key_from_bytes(key: bytes) -&gt; Ed25519PublicKey:\n    \"\"\"Returns an Ed25519 public key from 32 raw bytes.\"\"\"\n    return Ed25519PublicKey.from_public_bytes(key)\n</code></pre>"},{"location":"#dispatch.signature.key.public_key_from_pem","title":"<code>public_key_from_pem(pem)</code>","text":"<p>Returns an Ed25519 public key given a PEM representation.</p> Source code in <code>dispatch/signature/key.py</code> <pre><code>def public_key_from_pem(pem: str | bytes) -&gt; Ed25519PublicKey:\n    \"\"\"Returns an Ed25519 public key given a PEM representation.\"\"\"\n    if isinstance(pem, str):\n        pem = pem.encode()\n\n    key = load_pem_public_key(pem)\n    if not isinstance(key, Ed25519PublicKey):\n        raise ValueError(f\"unexpected public key type: {type(key)}\")\n    return key\n</code></pre>"},{"location":"#dispatch.signature.request","title":"<code>request</code>","text":""},{"location":"#dispatch.signature.request.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>A framework-agnostic representation of an HTTP request.</p> Source code in <code>dispatch/signature/request.py</code> <pre><code>@dataclass\nclass Request:\n    \"\"\"A framework-agnostic representation of an HTTP request.\"\"\"\n\n    method: str\n    url: str\n    headers: CaseInsensitiveDict\n    body: str | bytes\n</code></pre>"},{"location":"#dispatch.status","title":"<code>status</code>","text":""},{"location":"#dispatch.status.Status","title":"<code>Status</code>","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p> Source code in <code>dispatch/status.py</code> <pre><code>@enum.unique\nclass Status(int, enum.Enum):\n    \"\"\"Enumeration of the possible values that can be used in the return status\n    of functions.\n    \"\"\"\n\n    UNSPECIFIED = status_pb.STATUS_UNSPECIFIED\n    OK = status_pb.STATUS_OK\n    TIMEOUT = status_pb.STATUS_TIMEOUT\n    THROTTLED = status_pb.STATUS_THROTTLED\n    INVALID_ARGUMENT = status_pb.STATUS_INVALID_ARGUMENT\n    INVALID_RESPONSE = status_pb.STATUS_INVALID_RESPONSE\n    TEMPORARY_ERROR = status_pb.STATUS_TEMPORARY_ERROR\n    PERMANENT_ERROR = status_pb.STATUS_PERMANENT_ERROR\n    INCOMPATIBLE_STATE = status_pb.STATUS_INCOMPATIBLE_STATE\n\n    _proto: status_pb.Status\n</code></pre>"},{"location":"#dispatch.status.register_error_type","title":"<code>register_error_type(error_type, handler)</code>","text":"<p>Register an error type, and a handler which derives a Status from errors of this type.</p> Source code in <code>dispatch/status.py</code> <pre><code>def register_error_type(\n    error_type: Type[Exception], handler: Callable[[Exception], Status]\n):\n    \"\"\"Register an error type, and a handler which derives a Status from\n    errors of this type.\"\"\"\n    _ERROR_TYPES[error_type] = handler\n</code></pre>"},{"location":"#dispatch.status.register_output_type","title":"<code>register_output_type(output_type, handler)</code>","text":"<p>Register an output type, and a handler which derives a Status from outputs of this type.</p> Source code in <code>dispatch/status.py</code> <pre><code>def register_output_type(output_type: Type[Any], handler: Callable[[Any], Status]):\n    \"\"\"Register an output type, and a handler which derives a Status from\n    outputs of this type.\"\"\"\n    _OUTPUT_TYPES[output_type] = handler\n</code></pre>"},{"location":"#dispatch.status.status_for_error","title":"<code>status_for_error(error)</code>","text":"<p>Returns a Status that corresponds to the specified error.</p> Source code in <code>dispatch/status.py</code> <pre><code>def status_for_error(error: Exception) -&gt; Status:\n    \"\"\"Returns a Status that corresponds to the specified error.\"\"\"\n    # See if the error matches one of the registered types.\n    handler = _find_handler(error, _ERROR_TYPES)\n    if handler is not None:\n        return handler(error)\n\n    # If not, resort to standard error categorization.\n    status = Status.TEMPORARY_ERROR\n    try:\n        # Raise the exception and catch it so that the interpreter deals\n        # with exception groups and chaining for us.\n        raise error\n    except TimeoutError:\n        status = Status.TIMEOUT\n    except SyntaxError:\n        status = Status.PERMANENT_ERROR\n    except BaseException:\n        pass\n\n    return status\n</code></pre>"},{"location":"#dispatch.status.status_for_output","title":"<code>status_for_output(output)</code>","text":"<p>Returns a Status that corresponds to the specified output value.</p> Source code in <code>dispatch/status.py</code> <pre><code>def status_for_output(output: Any) -&gt; Status:\n    \"\"\"Returns a Status that corresponds to the specified output value.\"\"\"\n    # See if the output value matches one of the registered types.\n    handler = _find_handler(output, _OUTPUT_TYPES)\n    if handler is not None:\n        return handler(output)\n\n    return Status.OK\n</code></pre>"}]}