{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Python SDK","text":"<p>This is the API reference for the Python SDK of Dispatch.</p> <ul> <li>Tutorials and guides: docs.stealthrocket.cloud.</li> <li>Source: stealthrocket/dispatch-sdk-python.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> dispatch<ul> <li> client</li> <li> coroutine</li> <li> experimental<ul> <li> durable<ul> <li> function</li> <li> registry</li> <li> serializable</li> </ul> </li> <li> multicolor<ul> <li> compile</li> <li> desugar</li> <li> generator</li> <li> parse</li> <li> template</li> <li> yields</li> </ul> </li> </ul> </li> <li> fastapi</li> <li> function</li> <li> id</li> <li> integrations<ul> <li> http</li> <li> httpx</li> <li> requests</li> </ul> </li> <li> proto</li> <li> signature<ul> <li> digest</li> <li> key</li> <li> request</li> </ul> </li> <li> status</li> </ul> </li> </ul>"},{"location":"reference/dispatch/","title":"Index","text":""},{"location":"reference/dispatch/#dispatch","title":"dispatch","text":"<p>The Dispatch SDK for Python.</p>"},{"location":"reference/dispatch/#dispatch.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/#dispatch.Client","title":"Client","text":"<pre><code>Client(\n    api_key: None | str = None, api_url: None | str = None\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>None | str</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>None | str</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/#dispatch.Client.dispatch","title":"dispatch","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; Iterable[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>Iterable[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/#dispatch.Call","title":"Call  <code>dataclass</code>","text":"<p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/#dispatch.Error","title":"Error","text":"<pre><code>Error(\n    status: Status, type: str | None, message: str | None\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str | None</code> <p>arbitrary string, used for humans. Optional.</p> required <code>message</code> <code>str | None</code> <p>arbitrary message. Optional.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/#dispatch.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Status | None = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/#dispatch.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/#dispatch.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; tuple[list[Any], dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/#dispatch.Output","title":"Output","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/#dispatch.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(value: Any, status: Status | None = None) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/#dispatch.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/#dispatch.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(tail_call: Call) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/#dispatch.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: CallResult | None = None,\n    tail_call: Call | None = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/#dispatch.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(state: Any, calls: None | list[Call] = None) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/#dispatch.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/#dispatch.poll","title":"poll","text":"<pre><code>poll(calls: list[Call]) -&gt; list[CallResult]\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the coroutine when call results are ready.</p>"},{"location":"reference/dispatch/client/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> client","text":""},{"location":"reference/dispatch/client/#dispatch.client","title":"client","text":""},{"location":"reference/dispatch/client/#dispatch.client.Client","title":"Client","text":"<pre><code>Client(\n    api_key: None | str = None, api_url: None | str = None\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>None | str</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>None | str</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/client/#dispatch.client.Client.dispatch","title":"dispatch","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; Iterable[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>Iterable[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/coroutine/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine","title":"coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.CoroutineState","title":"CoroutineState  <code>dataclass</code>","text":"<p>Serialized representation of a coroutine.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.poll","title":"poll","text":"<pre><code>poll(calls: list[Call]) -&gt; list[CallResult]\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the coroutine when call results are ready.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.exit","title":"exit","text":"<pre><code>exit(\n    result: Any | None = None, tail_call: Call | None = None\n)\n</code></pre> <p>Exit exits a coroutine, with an optional result and optional tail call.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.schedule","title":"schedule","text":"<pre><code>schedule(func: DurableFunction, input: Input) -&gt; Output\n</code></pre> <p>Schedule schedules a coroutine with the provided input.</p>"},{"location":"reference/dispatch/fastapi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fastapi","text":""},{"location":"reference/dispatch/fastapi/#dispatch.fastapi","title":"fastapi","text":"<p>Integration of Dispatch programmable endpoints for FastAPI.</p> <p>Example:</p> <pre><code>import fastapi\nfrom dispatch.fastapi import Dispatch\n\napp = fastapi.FastAPI()\ndispatch = Dispatch(app, api_key=\"test-key\")\n\n@dispatch.function()\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\ndef read_root():\n    my_function.dispatch()\n</code></pre>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    app: FastAPI,\n    endpoint: str | None = None,\n    verification_key: Ed25519PublicKey | None = None,\n    api_key: str | None = None,\n    api_url: str | None = None,\n)\n</code></pre> <p>             Bases: <code>Registry</code></p> <p>A Dispatch programmable endpoint, powered by FastAPI.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app to configure.</p> required <code>endpoint</code> <code>str | None</code> <p>Full URL of the application the Dispatch programmable endpoint will be running on. Uses the value of the DISPATCH_ENDPOINT_URL environment variable by default.</p> <code>None</code> <code>verification_key</code> <code>Ed25519PublicKey | None</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable by default. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format. If not set, request signature verification is disabled (a warning will be logged by the constructor).</p> <code>None</code> <code>api_key</code> <code>str | None</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>str | None</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.function","title":"function","text":"<pre><code>function() -&gt; Callable[[FunctionType], Function]\n</code></pre> <p>Returns a decorator that registers functions.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.coroutine","title":"coroutine","text":"<pre><code>coroutine() -&gt; (\n    Callable[[FunctionType], Function | FunctionType]\n)\n</code></pre> <p>Returns a decorator that registers coroutine functions.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function() -&gt; (\n    Callable[[PrimitiveFunctionType], Function]\n)\n</code></pre> <p>Returns a decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/function/#dispatch.function","title":"function","text":""},{"location":"reference/dispatch/function/#dispatch.function.PrimitiveFunctionType","title":"PrimitiveFunctionType  <code>module-attribute</code>","text":"<pre><code>PrimitiveFunctionType: TypeAlias = Callable[[Input], Output]\n</code></pre> <p>A primitive function is a function that accepts a dispatch.function.Input and unconditionally returns a dispatch.function.Output. It must not raise exceptions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function","title":"Function","text":"<pre><code>Function(\n    endpoint: str,\n    client: Client | None,\n    name: str,\n    func: Callable[[Input], Output],\n)\n</code></pre> <p>Callable wrapper around a function meant to be used throughout the Dispatch Python SDK.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.dispatch","title":"dispatch","text":"<pre><code>dispatch(*args, **kwargs) -&gt; DispatchID\n</code></pre> <p>Dispatch a call to the function.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a Dispatch client has not been configured.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.primitive_dispatch","title":"primitive_dispatch","text":"<pre><code>primitive_dispatch(input: Any = None) -&gt; DispatchID\n</code></pre> <p>Dispatch a primitive call.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Any</code> <p>Input to the function.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a Dispatch client has not been configured.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.call_with","title":"call_with","text":"<pre><code>call_with(\n    *args, correlation_id: int | None = None, **kwargs\n) -&gt; Call\n</code></pre> <p>Create a Call for this function with the provided input. Useful to generate calls when polling.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>correlation_id</code> <code>int | None</code> <p>optional arbitrary integer the caller can use to match this call to a call result.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Output.poll().</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.primitive_call_with","title":"primitive_call_with","text":"<pre><code>primitive_call_with(\n    input: Any, correlation_id: int | None = None\n) -&gt; Call\n</code></pre> <p>Create a Call for this function with the provided input. Useful to generate calls when polling.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Any</code> <p>any pickle-able Python value that will be passed as input to this function.</p> required <code>correlation_id</code> <code>int | None</code> <p>optional arbitrary integer the caller can use to match this call to a call result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Output.poll().</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry","title":"Registry","text":"<pre><code>Registry(endpoint: str, client: Client | None)\n</code></pre> <p>Registry of local functions.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>URL of the endpoint that the function is accessible from.</p> required <code>client</code> <code>Client | None</code> <p>Optional client for the Dispatch API. If provided, calls to local functions can be dispatched directly.</p> required"},{"location":"reference/dispatch/function/#dispatch.function.Registry.function","title":"function","text":"<pre><code>function() -&gt; Callable[[FunctionType], Function]\n</code></pre> <p>Returns a decorator that registers functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.coroutine","title":"coroutine","text":"<pre><code>coroutine() -&gt; (\n    Callable[[FunctionType], Function | FunctionType]\n)\n</code></pre> <p>Returns a decorator that registers coroutine functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function() -&gt; (\n    Callable[[PrimitiveFunctionType], Function]\n)\n</code></pre> <p>Returns a decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/id/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> id","text":""},{"location":"reference/dispatch/id/#dispatch.id","title":"id","text":""},{"location":"reference/dispatch/id/#dispatch.id.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/proto/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto","title":"proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; tuple[list[Any], dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output","title":"Output","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(value: Any, status: Status | None = None) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(tail_call: Call) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: CallResult | None = None,\n    tail_call: Call | None = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(state: Any, calls: None | list[Call] = None) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Call","title":"Call  <code>dataclass</code>","text":"<p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.CallResult","title":"CallResult  <code>dataclass</code>","text":"<p>Result of a Call.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error","title":"Error","text":"<pre><code>Error(\n    status: Status, type: str | None, message: str | None\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str | None</code> <p>arbitrary string, used for humans. Optional.</p> required <code>message</code> <code>str | None</code> <p>arbitrary message. Optional.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Status | None = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/status/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> status","text":""},{"location":"reference/dispatch/status/#dispatch.status","title":"status","text":""},{"location":"reference/dispatch/status/#dispatch.status.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_error","title":"status_for_error","text":"<pre><code>status_for_error(error: Exception) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified error.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_output","title":"status_for_output","text":"<pre><code>status_for_output(output: Any) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified output value.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_error_type","title":"register_error_type","text":"<pre><code>register_error_type(\n    error_type: Type[Exception],\n    handler: Callable[[Exception], Status],\n)\n</code></pre> <p>Register an error type, and a handler which derives a Status from errors of this type.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_output_type","title":"register_output_type","text":"<pre><code>register_output_type(\n    output_type: Type[Any], handler: Callable[[Any], Status]\n)\n</code></pre> <p>Register an output type, and a handler which derives a Status from outputs of this type.</p>"},{"location":"reference/dispatch/experimental/","title":"Index","text":""},{"location":"reference/dispatch/experimental/#dispatch.experimental","title":"experimental","text":""},{"location":"reference/dispatch/experimental/durable/","title":"Index","text":""},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable","title":"durable","text":"<p>A decorator that makes generators and coroutines serializable.</p> <p>This module defines a @durable decorator that can be applied to generator functions and async functions. The generator and coroutine instances they create can be pickled.</p> <p>Example usage:</p> <pre><code>import pickle\nfrom dispatch.experimental.durable import durable\n\n@durable\ndef my_generator():\n    for i in range(3):\n        yield i\n\n# Run the generator to its first yield point:\ng = my_generator()\nprint(next(g))  # 0\n\n# Make a copy, and consume the remaining items:\nb = pickle.dumps(g)\ng2 = pickle.loads(b)\nprint(next(g2))  # 1\nprint(next(g2))  # 2\n\n# The original is not affected:\nprint(next(g))  # 1\nprint(next(g))  # 2\n</code></pre>"},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable.durable","title":"durable","text":"<pre><code>durable(fn) -&gt; DurableFunction\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <p>A generator function or async function.</p> required"},{"location":"reference/dispatch/experimental/durable/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function","title":"function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableFunction","title":"DurableFunction","text":"<pre><code>DurableFunction(fn: FunctionType)\n</code></pre> <p>A wrapper for generator functions and async functions that make their generator and coroutine instances serializable.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableGenerator","title":"DurableGenerator","text":"<pre><code>DurableGenerator(\n    generator: GeneratorType,\n    registered_fn: RegisteredFunction,\n    *args: Any,\n    coro_await: bool = False,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Generator[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a generator that makes it serializable (can be pickled). Instances behave like the generators they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableCoroutine","title":"DurableCoroutine","text":"<pre><code>DurableCoroutine(\n    coroutine: CoroutineType,\n    registered_fn: RegisteredFunction,\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Coroutine[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a coroutine that makes it serializable (can be pickled). Instances behave like the coroutines they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.durable","title":"durable","text":"<pre><code>durable(fn) -&gt; DurableFunction\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <p>A generator function or async function.</p> required"},{"location":"reference/dispatch/experimental/durable/registry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry","title":"registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.RegisteredFunction","title":"RegisteredFunction  <code>dataclass</code>","text":"<p>A function that can be referenced in durable state.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.register_function","title":"register_function","text":"<pre><code>register_function(fn: FunctionType) -&gt; RegisteredFunction\n</code></pre> <p>Register a function in the in-memory function registry.</p> <p>When serializing a registered function, a reference to the function is stored along with details about its location and contents. When deserializing the function, the registry is consulted in order to find the function associated with the reference (and in order to check whether the function is the same).</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to register.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>RegisteredFunction</code> <p>Unique identifier for the function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The function conflicts with another registered function.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.lookup_function","title":"lookup_function","text":"<pre><code>lookup_function(key: str) -&gt; RegisteredFunction\n</code></pre> <p>Lookup a registered function by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for the function.</p> required <p>Returns:</p> Name Type Description <code>RegisteredFunction</code> <code>RegisteredFunction</code> <p>the function that was registered with the specified key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>A function has not been registered with this key.</p>"},{"location":"reference/dispatch/experimental/durable/serializable/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> serializable","text":""},{"location":"reference/dispatch/experimental/durable/serializable/#dispatch.experimental.durable.serializable","title":"serializable","text":""},{"location":"reference/dispatch/experimental/durable/serializable/#dispatch.experimental.durable.serializable.Serializable","title":"Serializable","text":"<pre><code>Serializable(\n    g: GeneratorType | CoroutineType,\n    registered_fn: RegisteredFunction,\n    *args: Any,\n    coro_await: bool = False,\n    **kwargs: Any\n)\n</code></pre> <p>A wrapper for a generator or coroutine that makes it serializable.</p>"},{"location":"reference/dispatch/experimental/multicolor/","title":"Index","text":""},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor","title":"multicolor","text":""},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor.NoSourceError","title":"NoSourceError","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Function source code is not available.</p>"},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor.CustomYield","title":"CustomYield  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a function marked with @yields.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Any</code> <p>The type of yield that was specified in the @yields decorator.</p> <code>args</code> <code>list[Any]</code> <p>Positional arguments to the function call.</p> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to the function call.</p>"},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor.GeneratorYield","title":"GeneratorYield  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a generator.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The value that was yielded from the generator.</p>"},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor.compile_function","title":"compile_function","text":"<pre><code>compile_function(\n    fn: FunctionType,\n    decorator=None,\n    cache_key: str = \"default\",\n) -&gt; FunctionType | MethodType\n</code></pre> <p>Compile a regular function into a generator that yields data passed to functions marked with the @multicolor.yields decorator. Decorated yield functions can be called from anywhere in the call stack, and functions in between do not have to be generators or async functions (coroutines).</p> <p>Example:</p> <pre><code>@multicolor.yields(type=\"sleep\")\ndef sleep(seconds): ...\n\ndef parent():\n    sleep(3)  # yield point\n\ndef grandparent():\n    parent()\n\ncompiled_grandparent = multicolor.compile_function(grandparent)\ngenerator = compiled_grandparent()\nfor item in generator:\n    print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n</code></pre> <p>Two-way data flow works as expected. At a yield point, generator.send(value) can be used to send data back to the yield point and to resume execution. The data sent back will be the return value of the function decorated with @multicolor.yields:</p> <pre><code>@multicolor.yields(type=\"add\")\ndef add(a: int, b: int) -&gt; int:\n    return a + b  # default/synchronous implementation\n\ndef scheduler(generator):\n    try:\n        send = None\n        while True:\n            item = generator.send(send)\n            match item:\n                case multicolor.CustomYield(type=\"add\"):\n                    a, b = item.args\n                    print(f\"adding {a} + {b}\")\n                    send = a + b\n    except StopIteration as e:\n        return e.value  # return value\n\ndef adder(a: int, b: int) -&gt; int:\n    return add(a, b)\n\ncompiled_adder = multicolor.compile_function(adder)\ngenerator = compiled_adder(1, 2)\nresult = scheduler(generator)\nprint(result) # 3\n</code></pre> <p>The @multicolor.yields decorator does not change the implementation of the function it decorates. If the function is run without being compiled, the default implementation will be used instead:</p> <pre><code>print(adder(1, 2))  # 3\n</code></pre> <p>The default implementation could also raise an error, to ensure that the function is only ever called from a compiled function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to compile.</p> required <code>decorator</code> <p>An optional decorator to apply to the compiled function.</p> <code>None</code> <code>cache_key</code> <code>str</code> <p>Cache key to use when caching compiled functions.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>FunctionType</code> <code>FunctionType | MethodType</code> <p>A compiled generator function.</p>"},{"location":"reference/dispatch/experimental/multicolor/#dispatch.experimental.multicolor.no_yields","title":"no_yields","text":"<pre><code>no_yields(fn)\n</code></pre> <p>Decorator that hints that a function (and anything called recursively) does not yield.</p>"},{"location":"reference/dispatch/experimental/multicolor/compile/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> compile","text":""},{"location":"reference/dispatch/experimental/multicolor/compile/#dispatch.experimental.multicolor.compile","title":"compile","text":""},{"location":"reference/dispatch/experimental/multicolor/compile/#dispatch.experimental.multicolor.compile.FunctionColor","title":"FunctionColor","text":"<p>             Bases: <code>Enum</code></p> <p>Color (aka. type/flavor) of a function.</p> <p>There are four colors of functions in Python: * regular (e.g. def fn(): pass) * generator (e.g. def fn(): yield) * async (e.g. async def fn(): pass) * async generator (e.g. async def fn(): yield)</p> <p>Only the first two colors are supported at this time.</p>"},{"location":"reference/dispatch/experimental/multicolor/compile/#dispatch.experimental.multicolor.compile.GeneratorTransformer","title":"GeneratorTransformer","text":"<p>             Bases: <code>NodeTransformer</code></p> <p>Wrap ast.Yield values in a GeneratorYield container.</p>"},{"location":"reference/dispatch/experimental/multicolor/compile/#dispatch.experimental.multicolor.compile.CallTransformer","title":"CallTransformer","text":"<p>             Bases: <code>NodeTransformer</code></p> <p>Replace explicit function calls with a gadget that recursively compiles functions into generators and then replaces the function call with a yield from.</p> <p>The transformations are only valid for ASTs that have passed through the desugaring pass; only ast.Expr(value=ast.Call(...)) and ast.Assign(targets=..., value=ast.Call(..)) nodes are transformed here.</p>"},{"location":"reference/dispatch/experimental/multicolor/compile/#dispatch.experimental.multicolor.compile.compile_function","title":"compile_function","text":"<pre><code>compile_function(\n    fn: FunctionType,\n    decorator=None,\n    cache_key: str = \"default\",\n) -&gt; FunctionType | MethodType\n</code></pre> <p>Compile a regular function into a generator that yields data passed to functions marked with the @multicolor.yields decorator. Decorated yield functions can be called from anywhere in the call stack, and functions in between do not have to be generators or async functions (coroutines).</p> <p>Example:</p> <pre><code>@multicolor.yields(type=\"sleep\")\ndef sleep(seconds): ...\n\ndef parent():\n    sleep(3)  # yield point\n\ndef grandparent():\n    parent()\n\ncompiled_grandparent = multicolor.compile_function(grandparent)\ngenerator = compiled_grandparent()\nfor item in generator:\n    print(item)  # multicolor.CustomYield(type=\"sleep\", args=[3])\n</code></pre> <p>Two-way data flow works as expected. At a yield point, generator.send(value) can be used to send data back to the yield point and to resume execution. The data sent back will be the return value of the function decorated with @multicolor.yields:</p> <pre><code>@multicolor.yields(type=\"add\")\ndef add(a: int, b: int) -&gt; int:\n    return a + b  # default/synchronous implementation\n\ndef scheduler(generator):\n    try:\n        send = None\n        while True:\n            item = generator.send(send)\n            match item:\n                case multicolor.CustomYield(type=\"add\"):\n                    a, b = item.args\n                    print(f\"adding {a} + {b}\")\n                    send = a + b\n    except StopIteration as e:\n        return e.value  # return value\n\ndef adder(a: int, b: int) -&gt; int:\n    return add(a, b)\n\ncompiled_adder = multicolor.compile_function(adder)\ngenerator = compiled_adder(1, 2)\nresult = scheduler(generator)\nprint(result) # 3\n</code></pre> <p>The @multicolor.yields decorator does not change the implementation of the function it decorates. If the function is run without being compiled, the default implementation will be used instead:</p> <pre><code>print(adder(1, 2))  # 3\n</code></pre> <p>The default implementation could also raise an error, to ensure that the function is only ever called from a compiled function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to compile.</p> required <code>decorator</code> <p>An optional decorator to apply to the compiled function.</p> <code>None</code> <code>cache_key</code> <code>str</code> <p>Cache key to use when caching compiled functions.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>FunctionType</code> <code>FunctionType | MethodType</code> <p>A compiled generator function.</p>"},{"location":"reference/dispatch/experimental/multicolor/desugar/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> desugar","text":""},{"location":"reference/dispatch/experimental/multicolor/desugar/#dispatch.experimental.multicolor.desugar","title":"desugar","text":""},{"location":"reference/dispatch/experimental/multicolor/desugar/#dispatch.experimental.multicolor.desugar.Desugar","title":"Desugar","text":"<pre><code>Desugar()\n</code></pre> <p>The desugar pass simplifies subsequent AST transformations that need to replace an expression (e.g. a function call) with a statement (e.g. an if branch) in a function definition.</p> <p>The pass recursively simplifies control flow and compound expressions in a function definition such that: - expressions that are children of statements either have no children, or   only have children of type ast.Name and/or ast.Constant - those parent expressions are either part of an ast.Expr(value=expr)   statement or an ast.Assign(value=expr) statement</p> <p>The pass does not recurse into lambda expressions, or nested function or class definitions.</p>"},{"location":"reference/dispatch/experimental/multicolor/desugar/#dispatch.experimental.multicolor.desugar.desugar_function","title":"desugar_function","text":"<pre><code>desugar_function(fn_def: FunctionDef) -&gt; FunctionDef\n</code></pre> <p>Desugar a function to simplify subsequent AST transformations.</p> <p>Parameters:</p> Name Type Description Default <code>fn_def</code> <code>FunctionDef</code> <p>A function definition.</p> required <p>Returns:</p> Name Type Description <code>FunctionDef</code> <code>FunctionDef</code> <p>The desugared function definition.</p>"},{"location":"reference/dispatch/experimental/multicolor/generator/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> generator","text":""},{"location":"reference/dispatch/experimental/multicolor/generator/#dispatch.experimental.multicolor.generator","title":"generator","text":""},{"location":"reference/dispatch/experimental/multicolor/generator/#dispatch.experimental.multicolor.generator.YieldCounter","title":"YieldCounter","text":"<pre><code>YieldCounter()\n</code></pre> <p>             Bases: <code>NodeVisitor</code></p> <p>AST visitor that walks an ast.FunctionDef to count yield and yield from statements.</p> <p>The resulting count can be used to determine if the input function is a generator or not.</p> <p>Yields from nested function/class definitions are not counted.</p>"},{"location":"reference/dispatch/experimental/multicolor/generator/#dispatch.experimental.multicolor.generator.is_generator","title":"is_generator","text":"<pre><code>is_generator(fn_def: FunctionDef) -&gt; bool\n</code></pre> <p>Returns a boolean indicating whether a function is a generator function.</p> <p>Parameters:</p> Name Type Description Default <code>fn_def</code> <code>FunctionDef</code> <p>A function definition.</p> required"},{"location":"reference/dispatch/experimental/multicolor/generator/#dispatch.experimental.multicolor.generator.empty_generator","title":"empty_generator","text":"<pre><code>empty_generator()\n</code></pre> <p>A generator that yields nothing.</p> <p>A <code>yield from</code> this generator can be inserted into a function definition in order to turn the function into a generator, without causing any visible side effects.</p>"},{"location":"reference/dispatch/experimental/multicolor/parse/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parse","text":""},{"location":"reference/dispatch/experimental/multicolor/parse/#dispatch.experimental.multicolor.parse","title":"parse","text":""},{"location":"reference/dispatch/experimental/multicolor/parse/#dispatch.experimental.multicolor.parse.NoSourceError","title":"NoSourceError","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Function source code is not available.</p>"},{"location":"reference/dispatch/experimental/multicolor/parse/#dispatch.experimental.multicolor.parse.parse_function","title":"parse_function","text":"<pre><code>parse_function(\n    fn: FunctionType,\n) -&gt; tuple[Module, FunctionDef]\n</code></pre> <p>Parse an AST from a function. The function source must be available.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to parse.</p> required <p>Raises:</p> Type Description <code>NoSourceError</code> <p>If the function source cannot be retrieved.</p>"},{"location":"reference/dispatch/experimental/multicolor/template/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> template","text":""},{"location":"reference/dispatch/experimental/multicolor/template/#dispatch.experimental.multicolor.template","title":"template","text":""},{"location":"reference/dispatch/experimental/multicolor/template/#dispatch.experimental.multicolor.template.NameTransformer","title":"NameTransformer","text":"<pre><code>NameTransformer(**replacements: expr | stmt)\n</code></pre> <p>             Bases: <code>NodeTransformer</code></p> <p>Replace ast.Name nodes in an AST.</p>"},{"location":"reference/dispatch/experimental/multicolor/template/#dispatch.experimental.multicolor.template.rewrite_template","title":"rewrite_template","text":"<pre><code>rewrite_template(\n    template: str, **replacements: expr | stmt\n) -&gt; list[stmt]\n</code></pre> <p>Create an AST by parsing a template string and then replacing embedded identifiers with the provided AST nodes.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>String containing source code (one or more statements).</p> required <code>**replacements</code> <code>expr | stmt</code> <p>Dictionary mapping identifiers to replacement nodes.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[stmt]</code> <p>list[ast.stmt]: List of AST statements.</p>"},{"location":"reference/dispatch/experimental/multicolor/yields/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> yields","text":""},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields","title":"yields","text":""},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields.YieldType","title":"YieldType","text":"<p>Base class for yield types.</p>"},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields.CustomYield","title":"CustomYield  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a function marked with @yields.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Any</code> <p>The type of yield that was specified in the @yields decorator.</p> <code>args</code> <code>list[Any]</code> <p>Positional arguments to the function call.</p> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to the function call.</p>"},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields.GeneratorYield","title":"GeneratorYield  <code>dataclass</code>","text":"<p>             Bases: <code>YieldType</code></p> <p>A yield from a generator.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Any</code> <p>The value that was yielded from the generator.</p>"},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields.yields","title":"yields","text":"<pre><code>yields(type: Any)\n</code></pre> <p>Returns a decorator that marks functions as a type of yield.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Any</code> <p>Opaque type for this yield.</p> required"},{"location":"reference/dispatch/experimental/multicolor/yields/#dispatch.experimental.multicolor.yields.no_yields","title":"no_yields","text":"<pre><code>no_yields(fn)\n</code></pre> <p>Decorator that hints that a function (and anything called recursively) does not yield.</p>"},{"location":"reference/dispatch/integrations/","title":"Index","text":""},{"location":"reference/dispatch/integrations/#dispatch.integrations","title":"integrations","text":""},{"location":"reference/dispatch/integrations/http/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http","title":"http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http.http_response_code_status","title":"http_response_code_status","text":"<pre><code>http_response_code_status(code: int) -&gt; Status\n</code></pre> <p>Returns a Status that's broadly equivalent to an HTTP response status code.</p>"},{"location":"reference/dispatch/integrations/httpx/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> httpx","text":""},{"location":"reference/dispatch/integrations/httpx/#dispatch.integrations.httpx","title":"httpx","text":""},{"location":"reference/dispatch/integrations/requests/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> requests","text":""},{"location":"reference/dispatch/integrations/requests/#dispatch.integrations.requests","title":"requests","text":""},{"location":"reference/dispatch/signature/","title":"Index","text":""},{"location":"reference/dispatch/signature/#dispatch.signature","title":"signature","text":""},{"location":"reference/dispatch/signature/#dispatch.signature.sign_request","title":"sign_request","text":"<pre><code>sign_request(\n    request: Request,\n    key: Ed25519PrivateKey,\n    created: datetime,\n)\n</code></pre> <p>Sign a request using HTTP Message Signatures.</p> <p>The function adds three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The signature covers the request method, the URL host and path, the Content-Type header, and the request body. At this time, an ED25519 signature is generated with a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to sign.</p> required <code>key</code> <code>Ed25519PrivateKey</code> <p>The Ed25519 private key to use to generate the signature.</p> required <code>created</code> <code>datetime</code> <p>The times at which the signature is created.</p> required"},{"location":"reference/dispatch/signature/#dispatch.signature.verify_request","title":"verify_request","text":"<pre><code>verify_request(\n    request: Request,\n    key: Ed25519PublicKey,\n    max_age: timedelta,\n)\n</code></pre> <p>Verify a request containing an HTTP Message Signature.</p> <p>The function checks three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The function checks signatures that cover at least the request method, the URL host and path, the Content-Type header, and the request body (via the Content-Digest header). At this time, signatures must use a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to verify.</p> required <code>key</code> <code>Ed25519PublicKey</code> <p>The Ed25519 public key to use to verify the signature.</p> required <code>max_age</code> <code>timedelta</code> <p>The maximum age of the signature.</p> required"},{"location":"reference/dispatch/signature/digest/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest","title":"digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.generate_content_digest","title":"generate_content_digest","text":"<pre><code>generate_content_digest(body: str | bytes) -&gt; str\n</code></pre> <p>Returns a SHA-512 Content-Digest header, according to https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13</p>"},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.verify_content_digest","title":"verify_content_digest","text":"<pre><code>verify_content_digest(\n    digest_header: str | bytes, body: str | bytes\n)\n</code></pre> <p>Verify a SHA-256 or SHA-512 Content-Digest header matches a request body.</p>"},{"location":"reference/dispatch/signature/key/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key","title":"key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.KeyResolver","title":"KeyResolver  <code>dataclass</code>","text":"<p>             Bases: <code>HTTPSignatureKeyResolver</code></p> <p>KeyResolver provides public and private keys.</p> <p>At this time, multiple keys and/or key types are not supported. Keys must be Ed25519 keys and have an ID of DEFAULT_KEY_ID.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_pem","title":"public_key_from_pem","text":"<pre><code>public_key_from_pem(pem: str | bytes) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key given a PEM representation.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_bytes","title":"public_key_from_bytes","text":"<pre><code>public_key_from_bytes(key: bytes) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_pem","title":"private_key_from_pem","text":"<pre><code>private_key_from_pem(\n    pem: str | bytes, password: bytes | None = None\n) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key given a PEM representation and optional password.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_bytes","title":"private_key_from_bytes","text":"<pre><code>private_key_from_bytes(key: bytes) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/request/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request","title":"request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request.Request","title":"Request  <code>dataclass</code>","text":"<p>A framework-agnostic representation of an HTTP request.</p>"}]}