{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dispatch Python SDK","text":"<p>This is the API reference for the Python SDK of Dispatch.</p> <ul> <li>Tutorials and guides: docs.dispatch.run.</li> <li>Source: dispatchrun/dispatch-py.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> dispatch<ul> <li> coroutine</li> <li> error</li> <li> experimental<ul> <li> durable<ul> <li> function</li> <li> registry</li> </ul> </li> <li> lambda_handler</li> </ul> </li> <li> fastapi</li> <li> function</li> <li> http</li> <li> id</li> <li> integrations<ul> <li> http</li> <li> httpx</li> <li> openai</li> <li> requests</li> <li> slack</li> </ul> </li> <li> proto</li> <li> scheduler</li> <li> signature<ul> <li> digest</li> <li> key</li> <li> request</li> </ul> </li> <li> status</li> <li> test<ul> <li> client</li> <li> server</li> <li> service</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/dispatch/","title":"Index","text":""},{"location":"reference/dispatch/#dispatch","title":"dispatch","text":"<p>The Dispatch SDK for Python.</p>"},{"location":"reference/dispatch/#dispatch.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/#dispatch.Client","title":"Client","text":"<pre><code>Client(\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/#dispatch.Client.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/#dispatch.Client.dispatch","title":"dispatch","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; List[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/#dispatch.Registry","title":"Registry","text":"<pre><code>Registry(\n    endpoint: Optional[str] = None,\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Registry of functions.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Optional[str]</code> <p>URL of the endpoint that the function is accessible from. Uses the value of the DISPATCH_ENDPOINT_URL environment variable by default.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication when dispatching calls to functions. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use when dispatching calls to functions. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/#dispatch.Registry.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/#dispatch.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/#dispatch.Registry.set_client","title":"set_client","text":"<pre><code>set_client(client: Client)\n</code></pre> <p>Set the Client instance used to dispatch calls to registered functions.</p>"},{"location":"reference/dispatch/#dispatch.Registry.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/#dispatch.Reset","title":"Reset","text":"<pre><code>Reset(\n    func: Function[P, T], *args: args, **kwargs: kwargs\n)\n</code></pre> <p>             Bases: <code>TailCall</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/#dispatch.Call","title":"Call  <code>dataclass</code>","text":"<pre><code>Call(\n    function: str,\n    input: Optional[Any] = None,\n    endpoint: Optional[str] = None,\n    correlation_id: Optional[int] = None,\n)\n</code></pre> <p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/#dispatch.Error","title":"Error  <code>dataclass</code>","text":"<pre><code>Error(\n    status: Status,\n    type: str,\n    message: str,\n    value: Optional[Exception] = None,\n    traceback: Optional[bytes] = None,\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str</code> <p>arbitrary string, used for humans.</p> required <code>message</code> <code>str</code> <p>arbitrary message.</p> required <code>value</code> <code>Optional[Exception]</code> <p>arbitrary exception from which the error is derived. Optional.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/#dispatch.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Optional[Status] = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/#dispatch.Error.to_exception","title":"to_exception","text":"<pre><code>to_exception() -&gt; Exception\n</code></pre> <p>Returns an equivalent exception.</p>"},{"location":"reference/dispatch/#dispatch.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/#dispatch.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/#dispatch.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/#dispatch.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(\n    value: Any, status: Optional[Status] = None\n) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/#dispatch.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/#dispatch.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(\n    tail_call: Call, status: Status = Status.OK\n) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/#dispatch.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: Optional[CallResult] = None,\n    tail_call: Optional[Call] = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/#dispatch.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(\n    coroutine_state: Optional[bytes] = None,\n    calls: Optional[List[Call]] = None,\n    min_results: int = 1,\n    max_results: int = 10,\n    max_wait_seconds: Optional[int] = None,\n) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/#dispatch.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/#dispatch.all","title":"all","text":"<pre><code>all(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until all coroutines return or any coroutine raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/#dispatch.any","title":"any","text":"<pre><code>any(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or all coroutines raises an error. If all coroutines fail with uncaught exceptions, the exception(s) will be re-raised here.</p>"},{"location":"reference/dispatch/#dispatch.call","title":"call","text":"<pre><code>call(call: Call) -&gt; Any\n</code></pre> <p>Make an asynchronous function call and return its result. If the function call fails with an error, the error is raised.</p>"},{"location":"reference/dispatch/#dispatch.gather","title":"gather","text":"<pre><code>gather(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Alias for all.</p>"},{"location":"reference/dispatch/#dispatch.race","title":"race","text":"<pre><code>race(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/#dispatch.run","title":"run","text":"<pre><code>run(\n    init: Optional[Callable[P, None]] = None,\n    *args: args,\n    **kwargs: kwargs\n)\n</code></pre> <p>Run the default dispatch server. The default server uses a function registry where functions tagged by the <code>@dispatch.function</code> decorator are registered.</p> <p>This function is intended to be used with the <code>dispatch</code> CLI tool, which automatically configures environment variables to connect the local server to the Dispatch bridge API.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>Optional[Callable[P, None]]</code> <p>An initialization function called after binding the server address but before entering the event loop to handle requests.</p> <code>None</code> <code>args</code> <code>args</code> <p>Positional arguments to pass to the entrypoint.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to the entrypoint.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The return value of the entrypoint function.</p>"},{"location":"reference/dispatch/coroutine/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine","title":"coroutine","text":""},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.AnyException","title":"AnyException","text":"<pre><code>AnyException(exceptions: List[Exception])\n</code></pre> <p>             Bases: <code>RuntimeError</code></p> <p>Error indicating that all coroutines passed to any() failed with an exception.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.call","title":"call","text":"<pre><code>call(call: Call) -&gt; Any\n</code></pre> <p>Make an asynchronous function call and return its result. If the function call fails with an error, the error is raised.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.gather","title":"gather","text":"<pre><code>gather(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Alias for all.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.all","title":"all","text":"<pre><code>all(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until all coroutines return or any coroutine raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.any","title":"any","text":"<pre><code>any(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or all coroutines raises an error. If all coroutines fail with uncaught exceptions, the exception(s) will be re-raised here.</p>"},{"location":"reference/dispatch/coroutine/#dispatch.coroutine.race","title":"race","text":"<pre><code>race(*awaitables: Awaitable[Any]) -&gt; List[Any]\n</code></pre> <p>Concurrently run a set of coroutines, blocking until any coroutine returns or raises an error. If any coroutine fails with an uncaught exception, the exception will be re-raised here.</p>"},{"location":"reference/dispatch/error/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> error","text":""},{"location":"reference/dispatch/error/#dispatch.error","title":"error","text":""},{"location":"reference/dispatch/error/#dispatch.error.DispatchError","title":"DispatchError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Dispatch exceptions.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TimeoutError","title":"TimeoutError","text":"<p>             Bases: <code>DispatchError</code>, <code>TimeoutError</code></p> <p>Operation timed out.</p>"},{"location":"reference/dispatch/error/#dispatch.error.ThrottleError","title":"ThrottleError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Operation was throttled.</p>"},{"location":"reference/dispatch/error/#dispatch.error.InvalidArgumentError","title":"InvalidArgumentError","text":"<p>             Bases: <code>DispatchError</code>, <code>ValueError</code></p> <p>Invalid argument was received.</p>"},{"location":"reference/dispatch/error/#dispatch.error.InvalidResponseError","title":"InvalidResponseError","text":"<p>             Bases: <code>DispatchError</code>, <code>ValueError</code></p> <p>Invalid response was received.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TemporaryError","title":"TemporaryError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic temporary error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.PermanentError","title":"PermanentError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic permanent error. Used in cases where a more specific error class is not available, but the operation that failed should not be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.IncompatibleStateError","title":"IncompatibleStateError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Coroutine state is incompatible with the current interpreter and application revision.</p>"},{"location":"reference/dispatch/error/#dispatch.error.DNSError","title":"DNSError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic DNS error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.TCPError","title":"TCPError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic TCP error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.HTTPError","title":"HTTPError","text":"<p>             Bases: <code>DispatchError</code>, <code>ConnectionError</code></p> <p>Generic HTTP error. Used in cases where a more specific error class is not available, but the operation that failed should be attempted again.</p>"},{"location":"reference/dispatch/error/#dispatch.error.UnauthenticatedError","title":"UnauthenticatedError","text":"<p>             Bases: <code>DispatchError</code></p> <p>The caller did not authenticate with the resource.</p>"},{"location":"reference/dispatch/error/#dispatch.error.PermissionDeniedError","title":"PermissionDeniedError","text":"<p>             Bases: <code>DispatchError</code>, <code>PermissionError</code></p> <p>The caller does not have access to the resource.</p>"},{"location":"reference/dispatch/error/#dispatch.error.NotFoundError","title":"NotFoundError","text":"<p>             Bases: <code>DispatchError</code></p> <p>Generic not found error. Used in cases where a more specific error class is not available, but the operation that failed should not be attempted again.</p>"},{"location":"reference/dispatch/fastapi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fastapi","text":""},{"location":"reference/dispatch/fastapi/#dispatch.fastapi","title":"fastapi","text":"<p>Integration of Dispatch functions with FastAPI.</p> <p>Example:</p> <pre><code>import fastapi\nfrom dispatch.fastapi import Dispatch\n\napp = fastapi.FastAPI()\ndispatch = Dispatch(app, api_key=\"test-key\")\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@app.get(\"/\")\ndef read_root():\n    my_function.dispatch()\n</code></pre>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    app: FastAPI,\n    endpoint: Optional[str] = None,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>             Bases: <code>Registry</code></p> <p>A Dispatch instance, powered by FastAPI.</p> <p>It mounts a sub-app that implements the Dispatch gRPC interface.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app to configure.</p> required <code>endpoint</code> <code>Optional[str]</code> <p>Full URL of the application the Dispatch instance will be running on. Uses the value of the DISPATCH_ENDPOINT_URL environment variable by default.</p> <code>None</code> <code>verification_key</code> <code>Optional[Union[Ed25519PublicKey, str, bytes]]</code> <p>Key to use when verifying signed requests. Uses the value of the DISPATCH_VERIFICATION_KEY environment variable if omitted. The environment variable is expected to carry an Ed25519 public key in base64 or PEM format. If not set, request signature verification is disabled (a warning will be logged by the constructor).</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.set_client","title":"set_client","text":"<pre><code>set_client(client: Client)\n</code></pre> <p>Set the Client instance used to dispatch calls to registered functions.</p>"},{"location":"reference/dispatch/fastapi/#dispatch.fastapi.Dispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/function/#dispatch.function","title":"function","text":""},{"location":"reference/dispatch/function/#dispatch.function.PrimitiveFunctionType","title":"PrimitiveFunctionType  <code>module-attribute</code>","text":"<pre><code>PrimitiveFunctionType: TypeAlias = Callable[[Input], Output]\n</code></pre> <p>A primitive function is a function that accepts a dispatch.proto.Input and unconditionally returns a dispatch.proto.Output. It must not raise exceptions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function","title":"Function","text":"<pre><code>Function(\n    endpoint: str,\n    client: Client,\n    name: str,\n    primitive_func: PrimitiveFunctionType,\n)\n</code></pre> <p>             Bases: <code>PrimitiveFunction</code>, <code>Generic[P, T]</code></p> <p>Callable wrapper around a function meant to be used throughout the Dispatch Python SDK.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args: args, **kwargs: kwargs\n) -&gt; Coroutine[Any, Any, T]\n</code></pre> <p>Call the function asynchronously (through Dispatch), and return a coroutine that can be awaited to retrieve the call result.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.dispatch","title":"dispatch","text":"<pre><code>dispatch(*args: args, **kwargs: kwargs) -&gt; DispatchID\n</code></pre> <p>Dispatch an asynchronous call to the function without waiting for a result.</p> <p>The Registry this function was registered with must be initialized with a Client / api_key for this call facility to be available.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DispatchID</code> <code>DispatchID</code> <p>ID of the dispatched call.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a Dispatch client has not been configured.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Function.build_call","title":"build_call","text":"<pre><code>build_call(\n    *args: args,\n    correlation_id: Optional[int] = None,\n    **kwargs: kwargs\n) -&gt; Call\n</code></pre> <p>Create a Call for this function with the provided input. Useful to generate calls when using the Client.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>correlation_id</code> <code>Optional[int]</code> <p>optional arbitrary integer the caller can use to match this call to a call result.</p> <code>None</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Call</code> <code>Call</code> <p>can be passed to Client.dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Reset","title":"Reset","text":"<pre><code>Reset(\n    func: Function[P, T], *args: args, **kwargs: kwargs\n)\n</code></pre> <p>             Bases: <code>TailCall</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry","title":"Registry","text":"<pre><code>Registry(\n    endpoint: Optional[str] = None,\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Registry of functions.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Optional[str]</code> <p>URL of the endpoint that the function is accessible from. Uses the value of the DISPATCH_ENDPOINT_URL environment variable by default.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication when dispatching calls to functions. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use when dispatching calls to functions. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required arguments are missing.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.set_client","title":"set_client","text":"<pre><code>set_client(client: Client)\n</code></pre> <p>Set the Client instance used to dispatch calls to registered functions.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Registry.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Client","title":"Client","text":"<pre><code>Client(\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>Client for the Dispatch API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the API key is missing.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Client.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Client.dispatch","title":"dispatch","text":"<pre><code>dispatch(calls: Iterable[Call]) -&gt; List[DispatchID]\n</code></pre> <p>Dispatch function calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>Iterable[Call]</code> <p>Calls to dispatch.</p> required <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order as the inputs.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch","title":"Batch","text":"<pre><code>Batch(client: Client)\n</code></pre> <p>A batch of calls to dispatch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.add","title":"add","text":"<pre><code>add(\n    func: Function[P, T], *args: args, **kwargs: kwargs\n) -&gt; Batch\n</code></pre> <p>Add a call to the specified function to the batch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.add_call","title":"add_call","text":"<pre><code>add_call(call: Call) -&gt; Batch\n</code></pre> <p>Add a Call to the batch.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.dispatch","title":"dispatch","text":"<pre><code>dispatch() -&gt; List[DispatchID]\n</code></pre> <p>Dispatch dispatches the calls asynchronously.</p> <p>The batch is reset when the calls are dispatched successfully.</p> <p>Returns:</p> Type Description <code>List[DispatchID]</code> <p>Identifiers for the function calls, in the same order they</p> <code>List[DispatchID]</code> <p>were added.</p>"},{"location":"reference/dispatch/function/#dispatch.function.Batch.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the batch.</p>"},{"location":"reference/dispatch/http/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> http","text":""},{"location":"reference/dispatch/http/#dispatch.http","title":"http","text":"<p>Integration of Dispatch functions with http.</p>"},{"location":"reference/dispatch/http/#dispatch.http.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    registry: Registry,\n    verification_key: Optional[\n        Union[Ed25519PublicKey, str, bytes]\n    ] = None,\n)\n</code></pre> <p>A Dispatch instance to be serviced by a http server. The Dispatch class acts as a factory for DispatchHandler objects, by capturing the variables that would be shared between all DispatchHandler instances it created.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>Registry</code> <p>The registry of functions to be serviced.</p> required"},{"location":"reference/dispatch/id/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> id","text":""},{"location":"reference/dispatch/id/#dispatch.id","title":"id","text":""},{"location":"reference/dispatch/id/#dispatch.id.DispatchID","title":"DispatchID  <code>module-attribute</code>","text":"<pre><code>DispatchID: TypeAlias = str\n</code></pre> <p>Unique identifier in Dispatch.</p> <p>It should be treated as an opaque value.</p>"},{"location":"reference/dispatch/proto/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto","title":"proto","text":""},{"location":"reference/dispatch/proto/#dispatch.proto.TailCall","title":"TailCall","text":"<pre><code>TailCall(\n    call: Call, status: Status = Status.TEMPORARY_ERROR\n)\n</code></pre> <p>             Bases: <code>Exception</code></p> <p>The current coroutine is aborted and scheduling reset to be replaced with the call embedded in this exception.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Input","title":"Input","text":"<pre><code>Input(req: RunRequest)\n</code></pre> <p>The input to a primitive function.</p> <p>Functions always take a single argument of type Input. When the function is run for the first time, it receives the input. When the function is a coroutine that's resuming after a yield point, it receives the results of the yield directive. Use the is_first_call and is_resume properties to differentiate between the two cases.</p> <p>This class is intended to be used as read-only.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Input.input_arguments","title":"input_arguments","text":"<pre><code>input_arguments() -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]\n</code></pre> <p>Returns positional and keyword arguments carried by the input.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Arguments","title":"Arguments  <code>dataclass</code>","text":"<pre><code>Arguments(args: Tuple[Any, ...], kwargs: Dict[str, Any])\n</code></pre> <p>A container for positional and keyword arguments.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(proto: RunResponse)\n</code></pre> <p>The output of a primitive function.</p> <p>This class is meant to be instantiated and returned by authors of functions to indicate the follow up action they need to take. Use the various class methods create an instance of this class. For example Output.value() or Output.poll().</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.value","title":"value  <code>classmethod</code>","text":"<pre><code>value(\n    value: Any, status: Optional[Status] = None\n) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided return value.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.error","title":"error  <code>classmethod</code>","text":"<pre><code>error(error: Error) -&gt; Output\n</code></pre> <p>Terminally exit the function with the provided error.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.tail_call","title":"tail_call  <code>classmethod</code>","text":"<pre><code>tail_call(\n    tail_call: Call, status: Status = Status.OK\n) -&gt; Output\n</code></pre> <p>Terminally exit the function, and instruct the orchestrator to tail call the specified function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(\n    result: Optional[CallResult] = None,\n    tail_call: Optional[Call] = None,\n    status: Status = Status.OK,\n) -&gt; Output\n</code></pre> <p>Terminally exit the function.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Output.poll","title":"poll  <code>classmethod</code>","text":"<pre><code>poll(\n    coroutine_state: Optional[bytes] = None,\n    calls: Optional[List[Call]] = None,\n    min_results: int = 1,\n    max_results: int = 10,\n    max_wait_seconds: Optional[int] = None,\n) -&gt; Output\n</code></pre> <p>Suspend the function with a set of Calls, instructing the orchestrator to resume the function with the provided state when call results are ready.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Call","title":"Call  <code>dataclass</code>","text":"<pre><code>Call(\n    function: str,\n    input: Optional[Any] = None,\n    endpoint: Optional[str] = None,\n    correlation_id: Optional[int] = None,\n)\n</code></pre> <p>Instruction to call a function.</p> <p>Though this class can be built manually, it is recommended to use the with_call method of a Function instead.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.CallResult","title":"CallResult  <code>dataclass</code>","text":"<pre><code>CallResult(\n    correlation_id: Optional[int] = None,\n    output: Optional[Any] = None,\n    error: Optional[Error] = None,\n    dispatch_id: DispatchID = \"\",\n)\n</code></pre> <p>Result of a Call.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error","title":"Error  <code>dataclass</code>","text":"<pre><code>Error(\n    status: Status,\n    type: str,\n    message: str,\n    value: Optional[Exception] = None,\n    traceback: Optional[bytes] = None,\n)\n</code></pre> <p>Error when running a function.</p> <p>This is not a Python exception, but potentially part of a CallResult or Output.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>categorization of the error.</p> required <code>type</code> <code>str</code> <p>arbitrary string, used for humans.</p> required <code>message</code> <code>str</code> <p>arbitrary message.</p> required <code>value</code> <code>Optional[Exception]</code> <p>arbitrary exception from which the error is derived. Optional.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Neither type or message was provided or status is invalid.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error.from_exception","title":"from_exception  <code>classmethod</code>","text":"<pre><code>from_exception(\n    ex: Exception, status: Optional[Status] = None\n) -&gt; Error\n</code></pre> <p>Create an Error from a Python exception, using its class qualified named as type.</p> <p>The status tries to be inferred, but can be overridden. If it is not provided or cannot be inferred, it defaults to TEMPORARY_ERROR.</p>"},{"location":"reference/dispatch/proto/#dispatch.proto.Error.to_exception","title":"to_exception","text":"<pre><code>to_exception() -&gt; Exception\n</code></pre> <p>Returns an equivalent exception.</p>"},{"location":"reference/dispatch/scheduler/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> scheduler","text":""},{"location":"reference/dispatch/scheduler/#dispatch.scheduler","title":"scheduler","text":""},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CoroutineResult","title":"CoroutineResult  <code>dataclass</code>","text":"<pre><code>CoroutineResult(\n    coroutine_id: CoroutineID,\n    value: Optional[Any] = None,\n    error: Optional[Exception] = None,\n    call: Optional[Call] = None,\n    status: Status = Status.OK,\n)\n</code></pre> <p>The result from running a coroutine to completion.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CallResult","title":"CallResult  <code>dataclass</code>","text":"<pre><code>CallResult(\n    call_id: CallID,\n    value: Optional[Any] = None,\n    error: Optional[Exception] = None,\n)\n</code></pre> <p>The result of an asynchronous function call.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.CallFuture","title":"CallFuture  <code>dataclass</code>","text":"<pre><code>CallFuture(\n    result: Optional[CallResult] = None,\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.call() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.AllFuture","title":"AllFuture  <code>dataclass</code>","text":"<pre><code>AllFuture(\n    order: List[CoroutineID] = list(),\n    waiting: Set[CoroutineID] = set(),\n    results: Dict[CoroutineID, CoroutineResult] = dict(),\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.all() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.AnyFuture","title":"AnyFuture  <code>dataclass</code>","text":"<pre><code>AnyFuture(\n    order: List[CoroutineID] = list(),\n    waiting: Set[CoroutineID] = set(),\n    first_result: Optional[CoroutineResult] = None,\n    errors: Dict[CoroutineID, Exception] = dict(),\n    generic_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.any() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.RaceFuture","title":"RaceFuture  <code>dataclass</code>","text":"<pre><code>RaceFuture(\n    waiting: Set[CoroutineID] = set(),\n    first_result: Optional[CoroutineResult] = None,\n    first_error: Optional[Exception] = None,\n)\n</code></pre> <p>A future result of a dispatch.coroutine.race() operation.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.Coroutine","title":"Coroutine  <code>dataclass</code>","text":"<pre><code>Coroutine(\n    id: CoroutineID,\n    parent_id: Optional[CoroutineID],\n    coroutine: Union[DurableCoroutine, DurableGenerator],\n    result: Optional[Future] = None,\n)\n</code></pre> <p>An in-flight coroutine.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.State","title":"State  <code>dataclass</code>","text":"<pre><code>State(\n    version: str,\n    suspended: Dict[CoroutineID, Coroutine],\n    ready: List[Coroutine],\n    next_coroutine_id: int,\n    next_call_id: int,\n    prev_callers: List[Coroutine],\n    outstanding_calls: int,\n)\n</code></pre> <p>State of the scheduler and the coroutines it's managing.</p>"},{"location":"reference/dispatch/scheduler/#dispatch.scheduler.OneShotScheduler","title":"OneShotScheduler","text":"<pre><code>OneShotScheduler(\n    entry_point: Callable,\n    version: str = sys.version,\n    poll_min_results: int = 1,\n    poll_max_results: int = 10,\n    poll_max_wait_seconds: Optional[int] = None,\n)\n</code></pre> <p>Scheduler for local coroutines.</p> <p>It's a one-shot scheduler because it only runs one round of scheduling. When all local coroutines are suspended, the scheduler yields to Dispatch to take over scheduling asynchronous calls.</p> <p>Parameters:</p> Name Type Description Default <code>entry_point</code> <code>Callable</code> <p>Entry point for the main coroutine.</p> required <code>version</code> <code>str</code> <p>Version string to attach to scheduler/coroutine state. If the scheduler sees a version mismatch, it will respond to Dispatch with an INCOMPATIBLE_STATE status code.</p> <code>version</code> <code>poll_min_results</code> <code>int</code> <p>Minimum number of call results to wait for before coroutine execution should continue. Dispatch waits until this many results are available, or the poll_max_wait_seconds timeout is reached, whichever comes first.</p> <code>1</code> <code>poll_max_results</code> <code>int</code> <p>Maximum number of calls to receive from Dispatch per request.</p> <code>10</code> <code>poll_max_wait_seconds</code> <code>Optional[int]</code> <p>Maximum amount of time to suspend coroutines while waiting for call results. Optional.</p> <code>None</code>"},{"location":"reference/dispatch/status/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> status","text":""},{"location":"reference/dispatch/status/#dispatch.status","title":"status","text":""},{"location":"reference/dispatch/status/#dispatch.status.Status","title":"Status","text":"<p>             Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of the possible values that can be used in the return status of functions.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_error","title":"status_for_error","text":"<pre><code>status_for_error(error: BaseException) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified error.</p>"},{"location":"reference/dispatch/status/#dispatch.status.status_for_output","title":"status_for_output","text":"<pre><code>status_for_output(output: Any) -&gt; Status\n</code></pre> <p>Returns a Status that corresponds to the specified output value.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_error_type","title":"register_error_type","text":"<pre><code>register_error_type(\n    error_type: Type[Exception],\n    handler: Callable[[Exception], Status],\n)\n</code></pre> <p>Register an error type, and a handler which derives a Status from errors of this type.</p>"},{"location":"reference/dispatch/status/#dispatch.status.register_output_type","title":"register_output_type","text":"<pre><code>register_output_type(\n    output_type: Type[Any], handler: Callable[[Any], Status]\n)\n</code></pre> <p>Register an output type, and a handler which derives a Status from outputs of this type.</p>"},{"location":"reference/dispatch/experimental/","title":"Index","text":""},{"location":"reference/dispatch/experimental/#dispatch.experimental","title":"experimental","text":""},{"location":"reference/dispatch/experimental/lambda_handler/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> lambda_handler","text":""},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler","title":"lambda_handler","text":"<p>Integration of Dispatch programmable endpoints for FastAPI.</p> <p>Example:</p> <pre><code>from dispatch.experimental.lambda_handler import Dispatch\n\ndispatch = Dispatch(api_key=\"test-key\")\n\n@dispatch.function\ndef my_function():\n    return \"Hello World!\"\n\n@dispatch.function\ndef entrypoint():\n    my_function()\n\ndef handler(event, context):\n    dispatch.handle(event, context, entrypoint=\"entrypoint\")\n</code></pre>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(\n    api_key: Optional[str] = None,\n    api_url: Optional[str] = None,\n)\n</code></pre> <p>             Bases: <code>Registry</code></p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Dispatch API key to use for authentication. Uses the value of the DISPATCH_API_KEY environment variable by default.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The URL of the Dispatch API to use. Uses the value of the DISPATCH_API_URL environment variable if set, otherwise defaults to the public Dispatch API (DEFAULT_API_URL).</p> <code>None</code>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch.function","title":"function","text":"<pre><code>function(func)\n</code></pre> <p>Decorator that registers functions.</p>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch.primitive_function","title":"primitive_function","text":"<pre><code>primitive_function(\n    primitive_func: PrimitiveFunctionType,\n) -&gt; PrimitiveFunction\n</code></pre> <p>Decorator that registers primitive functions.</p>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch.set_client","title":"set_client","text":"<pre><code>set_client(client: Client)\n</code></pre> <p>Set the Client instance used to dispatch calls to registered functions.</p>"},{"location":"reference/dispatch/experimental/lambda_handler/#dispatch.experimental.lambda_handler.Dispatch.batch","title":"batch","text":"<pre><code>batch() -&gt; Batch\n</code></pre> <p>Returns a Batch instance that can be used to build a set of calls to dispatch.</p>"},{"location":"reference/dispatch/experimental/durable/","title":"Index","text":""},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable","title":"durable","text":"<p>A decorator that makes generators and coroutines serializable.</p> <p>This module defines a @durable decorator that can be applied to generator functions and async functions. The generator and coroutine instances they create can be pickled.</p> <p>Example usage:</p> <pre><code>import pickle\nfrom dispatch.experimental.durable import durable\n\n@durable\ndef my_generator():\n    for i in range(3):\n        yield i\n\n# Run the generator to its first yield point:\ng = my_generator()\nprint(next(g))  # 0\n\n# Make a copy, and consume the remaining items:\nb = pickle.dumps(g)\ng2 = pickle.loads(b)\nprint(next(g2))  # 1\nprint(next(g2))  # 2\n\n# The original is not affected:\nprint(next(g))  # 1\nprint(next(g))  # 2\n</code></pre>"},{"location":"reference/dispatch/experimental/durable/#dispatch.experimental.durable.durable","title":"durable","text":"<pre><code>durable(fn: Callable) -&gt; Callable\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p>"},{"location":"reference/dispatch/experimental/durable/function/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function","title":"function","text":""},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableFunction","title":"DurableFunction","text":"<pre><code>DurableFunction(fn: FunctionType)\n</code></pre> <p>A wrapper for generator functions and async functions that make their generator and coroutine instances serializable.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.Serializable","title":"Serializable","text":"<pre><code>Serializable(\n    g: Union[GeneratorType, CoroutineType],\n    registered_fn: RegisteredFunction,\n    wrapped_coroutine: Union[DurableCoroutine, None],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>A wrapper for a generator or coroutine that makes it serializable.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableCoroutine","title":"DurableCoroutine","text":"<pre><code>DurableCoroutine(\n    coroutine: CoroutineType,\n    registered_fn: RegisteredFunction,\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Coroutine[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a coroutine that makes it serializable (can be pickled). Instances behave like the coroutines they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.DurableGenerator","title":"DurableGenerator","text":"<pre><code>DurableGenerator(\n    generator: GeneratorType,\n    registered_fn: RegisteredFunction,\n    coroutine: Optional[DurableCoroutine],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Serializable</code>, <code>Generator[_YieldT, _SendT, _ReturnT]</code></p> <p>A wrapper for a generator that makes it serializable (can be pickled). Instances behave like the generators they wrap.</p>"},{"location":"reference/dispatch/experimental/durable/function/#dispatch.experimental.durable.function.durable","title":"durable","text":"<pre><code>durable(fn: Callable) -&gt; Callable\n</code></pre> <p>Returns a \"durable\" function that creates serializable generators or coroutines.</p>"},{"location":"reference/dispatch/experimental/durable/registry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry","title":"registry","text":""},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.RegisteredFunction","title":"RegisteredFunction  <code>dataclass</code>","text":"<pre><code>RegisteredFunction(\n    fn: FunctionType,\n    key: str,\n    filename: str,\n    lineno: int,\n    hash: str,\n)\n</code></pre> <p>A function that can be referenced in durable state.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.register_function","title":"register_function","text":"<pre><code>register_function(fn: FunctionType) -&gt; RegisteredFunction\n</code></pre> <p>Register a function in the in-memory function registry.</p> <p>When serializing a registered function, a reference to the function is stored along with details about its location and contents. When deserializing the function, the registry is consulted in order to find the function associated with the reference (and in order to check whether the function is the same).</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>FunctionType</code> <p>The function to register.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>RegisteredFunction</code> <p>Unique identifier for the function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The function conflicts with another registered function.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.lookup_function","title":"lookup_function","text":"<pre><code>lookup_function(key: str) -&gt; RegisteredFunction\n</code></pre> <p>Lookup a registered function by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Unique identifier for the function.</p> required <p>Returns:</p> Name Type Description <code>RegisteredFunction</code> <code>RegisteredFunction</code> <p>the function that was registered with the specified key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>A function has not been registered with this key.</p>"},{"location":"reference/dispatch/experimental/durable/registry/#dispatch.experimental.durable.registry.clear_functions","title":"clear_functions","text":"<pre><code>clear_functions()\n</code></pre> <p>Clear functions clears the registry.</p>"},{"location":"reference/dispatch/integrations/","title":"Index","text":""},{"location":"reference/dispatch/integrations/#dispatch.integrations","title":"integrations","text":""},{"location":"reference/dispatch/integrations/http/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http","title":"http","text":""},{"location":"reference/dispatch/integrations/http/#dispatch.integrations.http.http_response_code_status","title":"http_response_code_status","text":"<pre><code>http_response_code_status(code: int) -&gt; Status\n</code></pre> <p>Returns a Status that's broadly equivalent to an HTTP response status code.</p>"},{"location":"reference/dispatch/integrations/httpx/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> httpx","text":""},{"location":"reference/dispatch/integrations/httpx/#dispatch.integrations.httpx","title":"httpx","text":""},{"location":"reference/dispatch/integrations/openai/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openai","text":""},{"location":"reference/dispatch/integrations/openai/#dispatch.integrations.openai","title":"openai","text":""},{"location":"reference/dispatch/integrations/requests/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> requests","text":""},{"location":"reference/dispatch/integrations/requests/#dispatch.integrations.requests","title":"requests","text":""},{"location":"reference/dispatch/integrations/slack/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> slack","text":""},{"location":"reference/dispatch/integrations/slack/#dispatch.integrations.slack","title":"slack","text":""},{"location":"reference/dispatch/signature/","title":"Index","text":""},{"location":"reference/dispatch/signature/#dispatch.signature","title":"signature","text":""},{"location":"reference/dispatch/signature/#dispatch.signature.sign_request","title":"sign_request","text":"<pre><code>sign_request(\n    request: Request,\n    key: Ed25519PrivateKey,\n    created: datetime,\n)\n</code></pre> <p>Sign a request using HTTP Message Signatures.</p> <p>The function adds three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The signature covers the request method, the URL host and path, the Content-Type header, and the request body. At this time, an ED25519 signature is generated with a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to sign.</p> required <code>key</code> <code>Ed25519PrivateKey</code> <p>The Ed25519 private key to use to generate the signature.</p> required <code>created</code> <code>datetime</code> <p>The times at which the signature is created.</p> required"},{"location":"reference/dispatch/signature/#dispatch.signature.verify_request","title":"verify_request","text":"<pre><code>verify_request(\n    request: Request,\n    key: Ed25519PublicKey,\n    max_age: timedelta,\n)\n</code></pre> <p>Verify a request containing an HTTP Message Signature.</p> <p>The function checks three additional headers: Content-Digest, Signature-Input, and Signature. See the following spec for more details: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures</p> <p>The function checks signatures that cover at least the request method, the URL host and path, the Content-Type header, and the request body (via the Content-Digest header). At this time, signatures must use a hard-coded key ID of \"default\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request to verify.</p> required <code>key</code> <code>Ed25519PublicKey</code> <p>The Ed25519 public key to use to verify the signature.</p> required <code>max_age</code> <code>timedelta</code> <p>The maximum age of the signature.</p> required"},{"location":"reference/dispatch/signature/digest/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest","title":"digest","text":""},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.generate_content_digest","title":"generate_content_digest","text":"<pre><code>generate_content_digest(body: Union[str, bytes]) -&gt; str\n</code></pre> <p>Returns a SHA-512 Content-Digest header, according to https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-digest-headers-13</p>"},{"location":"reference/dispatch/signature/digest/#dispatch.signature.digest.verify_content_digest","title":"verify_content_digest","text":"<pre><code>verify_content_digest(\n    digest_header: Union[str, bytes],\n    body: Union[str, bytes],\n)\n</code></pre> <p>Verify a SHA-256 or SHA-512 Content-Digest header matches a request body.</p>"},{"location":"reference/dispatch/signature/key/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key","title":"key","text":""},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.KeyResolver","title":"KeyResolver  <code>dataclass</code>","text":"<pre><code>KeyResolver(\n    key_id: str,\n    public_key: Optional[Ed25519PublicKey] = None,\n    private_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>             Bases: <code>HTTPSignatureKeyResolver</code></p> <p>KeyResolver provides public and private keys.</p> <p>At this time, multiple keys and/or key types are not supported. Keys must be Ed25519 keys and have an ID of DEFAULT_KEY_ID.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_pem","title":"public_key_from_pem","text":"<pre><code>public_key_from_pem(\n    pem: Union[str, bytes]\n) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key given a PEM representation.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.public_key_from_bytes","title":"public_key_from_bytes","text":"<pre><code>public_key_from_bytes(key: bytes) -&gt; Ed25519PublicKey\n</code></pre> <p>Returns an Ed25519 public key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_pem","title":"private_key_from_pem","text":"<pre><code>private_key_from_pem(\n    pem: Union[str, bytes], password: Optional[bytes] = None\n) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key given a PEM representation and optional password.</p>"},{"location":"reference/dispatch/signature/key/#dispatch.signature.key.private_key_from_bytes","title":"private_key_from_bytes","text":"<pre><code>private_key_from_bytes(key: bytes) -&gt; Ed25519PrivateKey\n</code></pre> <p>Returns an Ed25519 private key from 32 raw bytes.</p>"},{"location":"reference/dispatch/signature/request/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request","title":"request","text":""},{"location":"reference/dispatch/signature/request/#dispatch.signature.request.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(\n    method: str,\n    url: str,\n    headers: CaseInsensitiveDict,\n    body: Union[str, bytes],\n)\n</code></pre> <p>A framework-agnostic representation of an HTTP request.</p>"},{"location":"reference/dispatch/test/","title":"Index","text":""},{"location":"reference/dispatch/test/#dispatch.test","title":"test","text":""},{"location":"reference/dispatch/test/#dispatch.test.EndpointClient","title":"EndpointClient","text":"<pre><code>EndpointClient(\n    http_client: Client,\n    signing_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>Test client for a Dispatch programmable endpoint.</p> <p>Note that this is different from dispatch.Client, which is a client for the Dispatch API. The EndpointClient is a client similar to the one that Dispatch itself would use to interact with an endpoint that provides functions.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>Client</code> <p>Client to use to make HTTP requests.</p> required <code>signing_key</code> <code>Optional[Ed25519PrivateKey]</code> <p>Optional Ed25519 private key to use to sign requests.</p> <code>None</code>"},{"location":"reference/dispatch/test/#dispatch.test.EndpointClient.run","title":"run","text":"<pre><code>run(request: RunRequest) -&gt; RunResponse\n</code></pre> <p>Send a run request to an endpoint and return its response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RunRequest</code> <p>A FunctionService Run request.</p> required <p>Returns:</p> Name Type Description <code>RunResponse</code> <code>RunResponse</code> <p>the response from the endpoint.</p>"},{"location":"reference/dispatch/test/#dispatch.test.EndpointClient.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    signing_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>Returns an EndpointClient for a Dispatch endpoint URL.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchServer","title":"DispatchServer","text":"<pre><code>DispatchServer(\n    service: DispatchServiceServicer,\n    hostname: str = \"127.0.0.1\",\n    port: int = 0,\n)\n</code></pre> <p>Test server for a Dispatch service. This is useful for testing a mock version of Dispatch locally (e.g. see dispatch.test.DispatchService).</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>DispatchServiceServicer</code> <p>Dispatch service to serve.</p> required <code>hostname</code> <code>str</code> <p>Hostname to bind to.</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port to bind to, or 0 to bind to any available port.</p> <code>0</code>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchServer.url","title":"url  <code>property</code>","text":"<pre><code>url\n</code></pre> <p>Returns the URL of the server.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchServer.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the server.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchServer.wait","title":"wait","text":"<pre><code>wait()\n</code></pre> <p>Block until the server terminates.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchServer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the server.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchService","title":"DispatchService","text":"<pre><code>DispatchService(\n    endpoint_client: EndpointClient,\n    api_key: Optional[str] = None,\n    retry_on_status: Optional[Set[Status]] = None,\n    collect_roundtrips: bool = False,\n)\n</code></pre> <p>             Bases: <code>DispatchServiceServicer</code></p> <p>Test instance of Dispatch that provides the bare minimum functionality required to test functions locally.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_client</code> <code>EndpointClient</code> <p>Client to use to interact with the local Dispatch endpoint (that provides the functions).</p> required <code>api_key</code> <code>Optional[str]</code> <p>Expected API key on requests to the service. If omitted, the value of the DISPATCH_API_KEY environment variable is used instead.</p> <code>None</code> <code>retry_on_status</code> <code>Optional[Set[Status]]</code> <p>Set of status codes to enable retries for.</p> <code>None</code> <code>collect_roundtrips</code> <code>bool</code> <p>Enable collection of request/response round-trips to the configured endpoint.</p> <code>False</code>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchService.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(request: DispatchRequest, context)\n</code></pre> <p>RPC handler for Dispatch requests. Requests are only queued for processing here.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchService.dispatch_calls","title":"dispatch_calls","text":"<pre><code>dispatch_calls()\n</code></pre> <p>Synchronously dispatch pending function calls to the configured endpoint.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchService.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start starts a background thread to continuously dispatch calls to the configured endpoint.</p>"},{"location":"reference/dispatch/test/#dispatch.test.DispatchService.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop stops the background thread that's dispatching calls to the configured endpoint.</p>"},{"location":"reference/dispatch/test/client/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> client","text":""},{"location":"reference/dispatch/test/client/#dispatch.test.client","title":"client","text":""},{"location":"reference/dispatch/test/client/#dispatch.test.client.EndpointClient","title":"EndpointClient","text":"<pre><code>EndpointClient(\n    http_client: Client,\n    signing_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>Test client for a Dispatch programmable endpoint.</p> <p>Note that this is different from dispatch.Client, which is a client for the Dispatch API. The EndpointClient is a client similar to the one that Dispatch itself would use to interact with an endpoint that provides functions.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>Client</code> <p>Client to use to make HTTP requests.</p> required <code>signing_key</code> <code>Optional[Ed25519PrivateKey]</code> <p>Optional Ed25519 private key to use to sign requests.</p> <code>None</code>"},{"location":"reference/dispatch/test/client/#dispatch.test.client.EndpointClient.run","title":"run","text":"<pre><code>run(request: RunRequest) -&gt; RunResponse\n</code></pre> <p>Send a run request to an endpoint and return its response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RunRequest</code> <p>A FunctionService Run request.</p> required <p>Returns:</p> Name Type Description <code>RunResponse</code> <code>RunResponse</code> <p>the response from the endpoint.</p>"},{"location":"reference/dispatch/test/client/#dispatch.test.client.EndpointClient.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    signing_key: Optional[Ed25519PrivateKey] = None,\n)\n</code></pre> <p>Returns an EndpointClient for a Dispatch endpoint URL.</p>"},{"location":"reference/dispatch/test/server/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> server","text":""},{"location":"reference/dispatch/test/server/#dispatch.test.server","title":"server","text":""},{"location":"reference/dispatch/test/server/#dispatch.test.server.DispatchServer","title":"DispatchServer","text":"<pre><code>DispatchServer(\n    service: DispatchServiceServicer,\n    hostname: str = \"127.0.0.1\",\n    port: int = 0,\n)\n</code></pre> <p>Test server for a Dispatch service. This is useful for testing a mock version of Dispatch locally (e.g. see dispatch.test.DispatchService).</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>DispatchServiceServicer</code> <p>Dispatch service to serve.</p> required <code>hostname</code> <code>str</code> <p>Hostname to bind to.</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port to bind to, or 0 to bind to any available port.</p> <code>0</code>"},{"location":"reference/dispatch/test/server/#dispatch.test.server.DispatchServer.url","title":"url  <code>property</code>","text":"<pre><code>url\n</code></pre> <p>Returns the URL of the server.</p>"},{"location":"reference/dispatch/test/server/#dispatch.test.server.DispatchServer.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the server.</p>"},{"location":"reference/dispatch/test/server/#dispatch.test.server.DispatchServer.wait","title":"wait","text":"<pre><code>wait()\n</code></pre> <p>Block until the server terminates.</p>"},{"location":"reference/dispatch/test/server/#dispatch.test.server.DispatchServer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the server.</p>"},{"location":"reference/dispatch/test/service/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> service","text":""},{"location":"reference/dispatch/test/service/#dispatch.test.service","title":"service","text":""},{"location":"reference/dispatch/test/service/#dispatch.test.service.RoundTrip","title":"RoundTrip  <code>module-attribute</code>","text":"<pre><code>RoundTrip: TypeAlias = Tuple[RunRequest, RunResponse]\n</code></pre> <p>A request to a Dispatch endpoint, and the response that was received.</p>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.CallType","title":"CallType","text":"<p>             Bases: <code>Enum</code></p> <p>Type of function call.</p>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.DispatchService","title":"DispatchService","text":"<pre><code>DispatchService(\n    endpoint_client: EndpointClient,\n    api_key: Optional[str] = None,\n    retry_on_status: Optional[Set[Status]] = None,\n    collect_roundtrips: bool = False,\n)\n</code></pre> <p>             Bases: <code>DispatchServiceServicer</code></p> <p>Test instance of Dispatch that provides the bare minimum functionality required to test functions locally.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_client</code> <code>EndpointClient</code> <p>Client to use to interact with the local Dispatch endpoint (that provides the functions).</p> required <code>api_key</code> <code>Optional[str]</code> <p>Expected API key on requests to the service. If omitted, the value of the DISPATCH_API_KEY environment variable is used instead.</p> <code>None</code> <code>retry_on_status</code> <code>Optional[Set[Status]]</code> <p>Set of status codes to enable retries for.</p> <code>None</code> <code>collect_roundtrips</code> <code>bool</code> <p>Enable collection of request/response round-trips to the configured endpoint.</p> <code>False</code>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.DispatchService.Dispatch","title":"Dispatch","text":"<pre><code>Dispatch(request: DispatchRequest, context)\n</code></pre> <p>RPC handler for Dispatch requests. Requests are only queued for processing here.</p>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.DispatchService.dispatch_calls","title":"dispatch_calls","text":"<pre><code>dispatch_calls()\n</code></pre> <p>Synchronously dispatch pending function calls to the configured endpoint.</p>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.DispatchService.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start starts a background thread to continuously dispatch calls to the configured endpoint.</p>"},{"location":"reference/dispatch/test/service/#dispatch.test.service.DispatchService.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop stops the background thread that's dispatching calls to the configured endpoint.</p>"}]}